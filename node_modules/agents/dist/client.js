import {
  __privateAdd,
  __privateGet,
  __privateSet
} from "./chunk-HMLY7DHA.js";

// src/client.ts
import {
  PartySocket
} from "partysocket";
function camelCaseToKebabCase(str) {
  if (str === str.toUpperCase() && str !== str.toLowerCase()) {
    return str.toLowerCase().replace(/_/g, "-");
  }
  let kebabified = str.replace(
    /[A-Z]/g,
    (letter) => `-${letter.toLowerCase()}`
  );
  kebabified = kebabified.startsWith("-") ? kebabified.slice(1) : kebabified;
  return kebabified.replace(/_/g, "-").replace(/-$/, "");
}
var _options, _pendingCalls;
var AgentClient = class extends PartySocket {
  constructor(options) {
    const agentNamespace = camelCaseToKebabCase(options.agent);
    super({
      prefix: "agents",
      party: agentNamespace,
      room: options.name || "default",
      ...options
    });
    __privateAdd(this, _options);
    __privateAdd(this, _pendingCalls, /* @__PURE__ */ new Map());
    this.agent = agentNamespace;
    this.name = options.name || "default";
    __privateSet(this, _options, options);
    this.addEventListener("message", (event) => {
      if (typeof event.data === "string") {
        let parsedMessage;
        try {
          parsedMessage = JSON.parse(event.data);
        } catch (error) {
          return;
        }
        if (parsedMessage.type === "cf_agent_state") {
          __privateGet(this, _options).onStateUpdate?.(parsedMessage.state, "server");
          return;
        }
        if (parsedMessage.type === "rpc") {
          const response = parsedMessage;
          const pending = __privateGet(this, _pendingCalls).get(response.id);
          if (!pending) return;
          if (!response.success) {
            pending.reject(new Error(response.error));
            __privateGet(this, _pendingCalls).delete(response.id);
            pending.stream?.onError?.(response.error);
            return;
          }
          if ("done" in response) {
            if (response.done) {
              pending.resolve(response.result);
              __privateGet(this, _pendingCalls).delete(response.id);
              pending.stream?.onDone?.(response.result);
            } else {
              pending.stream?.onChunk?.(response.result);
            }
          } else {
            pending.resolve(response.result);
            __privateGet(this, _pendingCalls).delete(response.id);
          }
        }
      }
    });
  }
  /**
   * @deprecated Use agentFetch instead
   */
  static fetch(_opts) {
    throw new Error(
      "AgentClient.fetch is not implemented, use agentFetch instead"
    );
  }
  setState(state) {
    this.send(JSON.stringify({ type: "cf_agent_state", state }));
    __privateGet(this, _options).onStateUpdate?.(state, "client");
  }
  /**
   * Call a method on the Agent
   * @param method Name of the method to call
   * @param args Arguments to pass to the method
   * @param streamOptions Options for handling streaming responses
   * @returns Promise that resolves with the method's return value
   */
  async call(method, args = [], streamOptions) {
    return new Promise((resolve, reject) => {
      const id = Math.random().toString(36).slice(2);
      __privateGet(this, _pendingCalls).set(id, {
        resolve: (value) => resolve(value),
        reject,
        stream: streamOptions,
        type: null
      });
      const request = {
        type: "rpc",
        id,
        method,
        args
      };
      this.send(JSON.stringify(request));
    });
  }
};
_options = new WeakMap();
_pendingCalls = new WeakMap();
function agentFetch(opts, init) {
  const agentNamespace = camelCaseToKebabCase(opts.agent);
  return PartySocket.fetch(
    {
      prefix: "agents",
      party: agentNamespace,
      room: opts.name || "default",
      ...opts
    },
    init
  );
}
export {
  AgentClient,
  agentFetch
};
//# sourceMappingURL=client.js.map