import {
  Agent
} from "../chunk-A65CRW2D.js";
import "../chunk-Q5ZBHY4Z.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet
} from "../chunk-HMLY7DHA.js";

// src/mcp/index.ts
import { DurableObject } from "cloudflare:workers";
import {
  InitializeRequestSchema,
  isJSONRPCError,
  isJSONRPCNotification,
  isJSONRPCRequest,
  isJSONRPCResponse,
  JSONRPCMessageSchema
} from "@modelcontextprotocol/sdk/types.js";
var MAXIMUM_MESSAGE_SIZE_BYTES = 4 * 1024 * 1024;
function handleCORS(request, corsOptions) {
  const origin = request.headers.get("Origin") || "*";
  const corsHeaders = {
    "Access-Control-Allow-Origin": corsOptions?.origin || origin,
    "Access-Control-Allow-Methods": corsOptions?.methods || "GET, POST, OPTIONS",
    "Access-Control-Allow-Headers": corsOptions?.headers || "Content-Type",
    "Access-Control-Max-Age": (corsOptions?.maxAge || 86400).toString()
  };
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  return null;
}
var _getWebSocket, _started;
var McpSSETransport = class {
  constructor(getWebSocket) {
    __privateAdd(this, _getWebSocket);
    __privateAdd(this, _started, false);
    __privateSet(this, _getWebSocket, getWebSocket);
  }
  async start() {
    if (__privateGet(this, _started)) {
      throw new Error("Transport already started");
    }
    __privateSet(this, _started, true);
  }
  async send(message) {
    if (!__privateGet(this, _started)) {
      throw new Error("Transport not started");
    }
    const websocket = __privateGet(this, _getWebSocket).call(this);
    if (!websocket) {
      throw new Error("WebSocket not connected");
    }
    try {
      websocket.send(JSON.stringify(message));
    } catch (error) {
      this.onerror?.(error);
      throw error;
    }
  }
  async close() {
    this.onclose?.();
  }
};
_getWebSocket = new WeakMap();
_started = new WeakMap();
var _getWebSocketForGetRequest, _getWebSocketForMessageID, _notifyResponseIdSent, _started2;
var McpStreamableHttpTransport = class {
  constructor(getWebSocketForMessageID, notifyResponseIdSent) {
    // TODO: If there is an open connection to send server-initiated messages
    // back, we should use that connection
    __privateAdd(this, _getWebSocketForGetRequest);
    // Get the appropriate websocket connection for a given message id
    __privateAdd(this, _getWebSocketForMessageID);
    // Notify the server that a response has been sent for a given message id
    // so that it may clean up it's mapping of message ids to connections
    // once they are no longer needed
    __privateAdd(this, _notifyResponseIdSent);
    __privateAdd(this, _started2, false);
    __privateSet(this, _getWebSocketForMessageID, getWebSocketForMessageID);
    __privateSet(this, _notifyResponseIdSent, notifyResponseIdSent);
    __privateSet(this, _getWebSocketForGetRequest, () => null);
  }
  async start() {
    if (__privateGet(this, _started2)) {
      throw new Error("Transport already started");
    }
    __privateSet(this, _started2, true);
  }
  async send(message) {
    if (!__privateGet(this, _started2)) {
      throw new Error("Transport not started");
    }
    let websocket = null;
    if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
      websocket = __privateGet(this, _getWebSocketForMessageID).call(this, message.id.toString());
      if (!websocket) {
        throw new Error(
          `Could not find WebSocket for message id: ${message.id}`
        );
      }
    } else if (isJSONRPCRequest(message)) {
      websocket = __privateGet(this, _getWebSocketForGetRequest).call(this);
    } else if (isJSONRPCNotification(message)) {
      websocket = null;
    }
    try {
      websocket?.send(JSON.stringify(message));
      if (isJSONRPCResponse(message)) {
        __privateGet(this, _notifyResponseIdSent).call(this, message.id.toString());
      }
    } catch (error) {
      this.onerror?.(error);
      throw error;
    }
  }
  async close() {
    this.onclose?.();
  }
};
_getWebSocketForGetRequest = new WeakMap();
_getWebSocketForMessageID = new WeakMap();
_notifyResponseIdSent = new WeakMap();
_started2 = new WeakMap();
var _status, _transport, _transportType, _requestIdToConnectionId, _agent, _McpAgent_instances, initialize_fn;
var _McpAgent = class _McpAgent extends DurableObject {
  constructor(ctx, env) {
    var _a;
    super(ctx, env);
    __privateAdd(this, _McpAgent_instances);
    __privateAdd(this, _status, "zero");
    __privateAdd(this, _transport);
    __privateAdd(this, _transportType, "unset");
    __privateAdd(this, _requestIdToConnectionId, /* @__PURE__ */ new Map());
    /**
     * Since McpAgent's _aren't_ yet real "Agents", let's only expose a couple of the methods
     * to the outer class: initialState/state/setState/onStateUpdate/sql
     */
    __privateAdd(this, _agent);
    this.initRun = false;
    const self = this;
    __privateSet(this, _agent, new (_a = class extends Agent {
      onStateUpdate(state, source) {
        return self.onStateUpdate(state, source);
      }
      async onMessage(connection, message) {
        return self.onMessage(connection, message);
      }
    }, _a.options = {
      hibernate: true
    }, _a)(ctx, env));
  }
  get mcp() {
    return __privateGet(this, _agent).mcp;
  }
  get state() {
    return __privateGet(this, _agent).state;
  }
  sql(strings, ...values) {
    return __privateGet(this, _agent).sql(strings, ...values);
  }
  setState(state) {
    return __privateGet(this, _agent).setState(state);
  }
  onStateUpdate(state, source) {
  }
  async onStart() {
    var _a;
    const self = this;
    __privateSet(this, _agent, new (_a = class extends Agent {
      constructor() {
        super(...arguments);
        this.initialState = self.initialState;
      }
      onStateUpdate(state, source) {
        return self.onStateUpdate(state, source);
      }
      async onMessage(connection, event) {
        return self.onMessage(connection, event);
      }
    }, _a.options = {
      hibernate: true
    }, _a)(this.ctx, this.env));
    this.props = await this.ctx.storage.get("props");
    __privateSet(this, _transportType, await this.ctx.storage.get(
      "transportType"
    ));
    await this._init(this.props);
    const server = await this.server;
    if (__privateGet(this, _transportType) === "sse") {
      __privateSet(this, _transport, new McpSSETransport(() => this.getWebSocket()));
      await server.connect(__privateGet(this, _transport));
    } else if (__privateGet(this, _transportType) === "streamable-http") {
      __privateSet(this, _transport, new McpStreamableHttpTransport(
        (id) => this.getWebSocketForResponseID(id),
        (id) => __privateGet(this, _requestIdToConnectionId).delete(id)
      ));
      await server.connect(__privateGet(this, _transport));
    }
  }
  async _init(props) {
    await this.ctx.storage.put("props", props ?? {});
    if (!this.ctx.storage.get("transportType")) {
      await this.ctx.storage.put("transportType", "unset");
    }
    this.props = props;
    if (!this.initRun) {
      this.initRun = true;
      await this.init();
    }
  }
  async setInitialized() {
    await this.ctx.storage.put("initialized", true);
  }
  async isInitialized() {
    return await this.ctx.storage.get("initialized") === true;
  }
  // Allow the worker to fetch a websocket connection to the agent
  async fetch(request) {
    if (__privateGet(this, _status) !== "started") {
      await __privateMethod(this, _McpAgent_instances, initialize_fn).call(this);
    }
    if (request.headers.get("Upgrade") !== "websocket") {
      return new Response("Expected WebSocket Upgrade request", {
        status: 400
      });
    }
    const url = new URL(request.url);
    const path = url.pathname;
    const server = await this.server;
    switch (path) {
      case "/sse": {
        const websockets = this.ctx.getWebSockets();
        if (websockets.length > 0) {
          return new Response("Websocket already connected", { status: 400 });
        }
        await this.ctx.storage.put("transportType", "sse");
        __privateSet(this, _transportType, "sse");
        if (!__privateGet(this, _transport)) {
          __privateSet(this, _transport, new McpSSETransport(() => this.getWebSocket()));
          await server.connect(__privateGet(this, _transport));
        }
        return __privateGet(this, _agent).fetch(request);
      }
      case "/streamable-http": {
        if (!__privateGet(this, _transport)) {
          __privateSet(this, _transport, new McpStreamableHttpTransport(
            (id) => this.getWebSocketForResponseID(id),
            (id) => __privateGet(this, _requestIdToConnectionId).delete(id)
          ));
          await server.connect(__privateGet(this, _transport));
        }
        await this.ctx.storage.put("transportType", "streamable-http");
        __privateSet(this, _transportType, "streamable-http");
        return __privateGet(this, _agent).fetch(request);
      }
      default:
        return new Response(
          "Internal Server Error: Expected /sse or /streamable-http path",
          {
            status: 500
          }
        );
    }
  }
  getWebSocket() {
    const websockets = this.ctx.getWebSockets();
    if (websockets.length === 0) {
      return null;
    }
    return websockets[0];
  }
  getWebSocketForResponseID(id) {
    const connectionId = __privateGet(this, _requestIdToConnectionId).get(id);
    if (connectionId === void 0) {
      return null;
    }
    return __privateGet(this, _agent).getConnection(connectionId) ?? null;
  }
  // All messages received here. This is currently never called
  async onMessage(connection, event) {
    if (__privateGet(this, _transportType) !== "streamable-http") {
      const err = new Error(
        "Internal Server Error: Expected streamable-http protocol"
      );
      __privateGet(this, _transport)?.onerror?.(err);
      return;
    }
    let message;
    try {
      const data = typeof event === "string" ? event : new TextDecoder().decode(event);
      message = JSONRPCMessageSchema.parse(JSON.parse(data));
    } catch (error) {
      __privateGet(this, _transport)?.onerror?.(error);
      return;
    }
    if (isJSONRPCRequest(message)) {
      __privateGet(this, _requestIdToConnectionId).set(message.id.toString(), connection.id);
    }
    __privateGet(this, _transport)?.onmessage?.(message);
  }
  // All messages received over SSE after the initial connection has been established
  // will be passed here
  async onSSEMcpMessage(sessionId, request) {
    if (__privateGet(this, _status) !== "started") {
      await __privateMethod(this, _McpAgent_instances, initialize_fn).call(this);
    }
    if (__privateGet(this, _transportType) !== "sse") {
      return new Error("Internal Server Error: Expected SSE protocol");
    }
    try {
      const message = await request.json();
      let parsedMessage;
      try {
        parsedMessage = JSONRPCMessageSchema.parse(message);
      } catch (error) {
        __privateGet(this, _transport)?.onerror?.(error);
        throw error;
      }
      __privateGet(this, _transport)?.onmessage?.(parsedMessage);
      return null;
    } catch (error) {
      __privateGet(this, _transport)?.onerror?.(error);
      return error;
    }
  }
  // Delegate all websocket events to the underlying agent
  async webSocketMessage(ws, event) {
    if (__privateGet(this, _status) !== "started") {
      await __privateMethod(this, _McpAgent_instances, initialize_fn).call(this);
    }
    return await __privateGet(this, _agent).webSocketMessage(ws, event);
  }
  // WebSocket event handlers for hibernation support
  async webSocketError(ws, error) {
    if (__privateGet(this, _status) !== "started") {
      await __privateMethod(this, _McpAgent_instances, initialize_fn).call(this);
    }
    return await __privateGet(this, _agent).webSocketError(ws, error);
  }
  async webSocketClose(ws, code, reason, wasClean) {
    if (__privateGet(this, _status) !== "started") {
      await __privateMethod(this, _McpAgent_instances, initialize_fn).call(this);
    }
    return await __privateGet(this, _agent).webSocketClose(ws, code, reason, wasClean);
  }
  static mount(path, {
    binding = "MCP_OBJECT",
    corsOptions
  } = {}) {
    return _McpAgent.serveSSE(path, { binding, corsOptions });
  }
  static serveSSE(path, {
    binding = "MCP_OBJECT",
    corsOptions
  } = {}) {
    let pathname = path;
    if (path === "/") {
      pathname = "/*";
    }
    const basePattern = new URLPattern({ pathname });
    const messagePattern = new URLPattern({ pathname: `${pathname}/message` });
    return {
      async fetch(request, env, ctx) {
        const corsResponse = handleCORS(request, corsOptions);
        if (corsResponse) return corsResponse;
        const url = new URL(request.url);
        const bindingValue = env[binding];
        if (bindingValue == null || typeof bindingValue !== "object") {
          console.error(
            `Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`
          );
          return new Response("Invalid binding", { status: 500 });
        }
        if (bindingValue.toString() !== "[object DurableObjectNamespace]") {
          return new Response("Invalid binding", { status: 500 });
        }
        const namespace = bindingValue;
        if (request.method === "GET" && basePattern.test(url)) {
          const sessionId = url.searchParams.get("sessionId") || namespace.newUniqueId().toString();
          const { readable, writable } = new TransformStream();
          const writer = writable.getWriter();
          const encoder = new TextEncoder();
          const endpointUrl = new URL(request.url);
          endpointUrl.pathname = encodeURI(`${pathname}/message`);
          endpointUrl.searchParams.set("sessionId", sessionId);
          const relativeUrlWithSession = endpointUrl.pathname + endpointUrl.search + endpointUrl.hash;
          const endpointMessage = `event: endpoint
data: ${relativeUrlWithSession}

`;
          writer.write(encoder.encode(endpointMessage));
          const id = namespace.idFromName(`sse:${sessionId}`);
          const doStub = namespace.get(id);
          await doStub._init(ctx.props);
          const upgradeUrl = new URL(request.url);
          upgradeUrl.pathname = "/sse";
          const response = await doStub.fetch(
            new Request(upgradeUrl, {
              headers: {
                Upgrade: "websocket",
                // Required by PartyServer
                "x-partykit-room": sessionId
              }
            })
          );
          const ws = response.webSocket;
          if (!ws) {
            console.error("Failed to establish WebSocket connection");
            await writer.close();
            return new Response("Failed to establish WebSocket connection", {
              status: 500
            });
          }
          ws.accept();
          ws.addEventListener("message", (event) => {
            async function onMessage(event2) {
              try {
                const message = JSON.parse(event2.data);
                const result = JSONRPCMessageSchema.safeParse(message);
                if (!result.success) {
                  return;
                }
                const messageText = `event: message
data: ${JSON.stringify(result.data)}

`;
                await writer.write(encoder.encode(messageText));
              } catch (error) {
                console.error("Error forwarding message to SSE:", error);
              }
            }
            onMessage(event).catch(console.error);
          });
          ws.addEventListener("error", (error) => {
            async function onError(error2) {
              try {
                await writer.close();
              } catch (e) {
              }
            }
            onError(error).catch(console.error);
          });
          ws.addEventListener("close", () => {
            async function onClose() {
              try {
                await writer.close();
              } catch (error) {
                console.error("Error closing SSE connection:", error);
              }
            }
            onClose().catch(console.error);
          });
          return new Response(readable, {
            headers: {
              "Content-Type": "text/event-stream",
              "Cache-Control": "no-cache",
              Connection: "keep-alive",
              "Access-Control-Allow-Origin": corsOptions?.origin || "*"
            }
          });
        }
        if (request.method === "POST" && messagePattern.test(url)) {
          const sessionId = url.searchParams.get("sessionId");
          if (!sessionId) {
            return new Response(
              `Missing sessionId. Expected POST to ${pathname} to initiate new one`,
              { status: 400 }
            );
          }
          const contentType = request.headers.get("content-type") || "";
          if (!contentType.includes("application/json")) {
            return new Response(`Unsupported content-type: ${contentType}`, {
              status: 400
            });
          }
          const contentLength = Number.parseInt(
            request.headers.get("content-length") || "0",
            10
          );
          if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {
            return new Response(
              `Request body too large: ${contentLength} bytes`,
              {
                status: 400
              }
            );
          }
          const id = namespace.idFromName(`sse:${sessionId}`);
          const doStub = namespace.get(id);
          const error = await doStub.onSSEMcpMessage(sessionId, request);
          if (error) {
            return new Response(error.message, {
              status: 400,
              headers: {
                "Content-Type": "text/event-stream",
                "Cache-Control": "no-cache",
                Connection: "keep-alive",
                "Access-Control-Allow-Origin": corsOptions?.origin || "*"
              }
            });
          }
          return new Response("Accepted", {
            status: 202,
            headers: {
              "Content-Type": "text/event-stream",
              "Cache-Control": "no-cache",
              Connection: "keep-alive",
              "Access-Control-Allow-Origin": corsOptions?.origin || "*"
            }
          });
        }
        return new Response("Not Found", { status: 404 });
      }
    };
  }
  static serve(path, {
    binding = "MCP_OBJECT",
    corsOptions
  } = {}) {
    let pathname = path;
    if (path === "/") {
      pathname = "/*";
    }
    const basePattern = new URLPattern({ pathname });
    return {
      async fetch(request, env, ctx) {
        const corsResponse = handleCORS(request, corsOptions);
        if (corsResponse) {
          return corsResponse;
        }
        const url = new URL(request.url);
        const bindingValue = env[binding];
        if (bindingValue == null || typeof bindingValue !== "object") {
          console.error(
            `Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`
          );
          return new Response("Invalid binding", { status: 500 });
        }
        if (bindingValue.toString() !== "[object DurableObjectNamespace]") {
          return new Response("Invalid binding", { status: 500 });
        }
        const namespace = bindingValue;
        if (request.method === "POST" && basePattern.test(url)) {
          const acceptHeader = request.headers.get("accept");
          if (!acceptHeader?.includes("application/json") || !acceptHeader.includes("text/event-stream")) {
            const body2 = JSON.stringify({
              jsonrpc: "2.0",
              error: {
                code: -32e3,
                message: "Not Acceptable: Client must accept both application/json and text/event-stream"
              },
              id: null
            });
            return new Response(body2, { status: 406 });
          }
          const ct = request.headers.get("content-type");
          if (!ct || !ct.includes("application/json")) {
            const body2 = JSON.stringify({
              jsonrpc: "2.0",
              error: {
                code: -32e3,
                message: "Unsupported Media Type: Content-Type must be application/json"
              },
              id: null
            });
            return new Response(body2, { status: 415 });
          }
          const contentLength = Number.parseInt(
            request.headers.get("content-length") ?? "0",
            10
          );
          if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {
            const body2 = JSON.stringify({
              jsonrpc: "2.0",
              error: {
                code: -32e3,
                message: `Request body too large. Maximum size is ${MAXIMUM_MESSAGE_SIZE_BYTES} bytes`
              },
              id: null
            });
            return new Response(body2, { status: 413 });
          }
          let sessionId = request.headers.get("mcp-session-id");
          let rawMessage;
          try {
            rawMessage = await request.json();
          } catch (error) {
            const body2 = JSON.stringify({
              jsonrpc: "2.0",
              error: {
                code: -32700,
                message: "Parse error: Invalid JSON"
              },
              id: null
            });
            return new Response(body2, { status: 400 });
          }
          let arrayMessage;
          if (Array.isArray(rawMessage)) {
            arrayMessage = rawMessage;
          } else {
            arrayMessage = [rawMessage];
          }
          let messages = [];
          for (const msg of arrayMessage) {
            if (!JSONRPCMessageSchema.safeParse(msg).success) {
              const body2 = JSON.stringify({
                jsonrpc: "2.0",
                error: {
                  code: -32700,
                  message: "Parse error: Invalid JSON-RPC message"
                },
                id: null
              });
              return new Response(body2, { status: 400 });
            }
          }
          messages = arrayMessage.map((msg) => JSONRPCMessageSchema.parse(msg));
          const isInitializationRequest = messages.some(
            (msg) => InitializeRequestSchema.safeParse(msg).success
          );
          if (isInitializationRequest && sessionId) {
            const body2 = JSON.stringify({
              jsonrpc: "2.0",
              error: {
                code: -32600,
                message: "Invalid Request: Initialization requests must not include a sessionId"
              },
              id: null
            });
            return new Response(body2, { status: 400 });
          }
          if (isInitializationRequest && messages.length > 1) {
            const body2 = JSON.stringify({
              jsonrpc: "2.0",
              error: {
                code: -32600,
                message: "Invalid Request: Only one initialization request is allowed"
              },
              id: null
            });
            return new Response(body2, { status: 400 });
          }
          if (!isInitializationRequest && !sessionId) {
            const body2 = JSON.stringify({
              jsonrpc: "2.0",
              error: {
                code: -32e3,
                message: "Bad Request: Mcp-Session-Id header is required"
              },
              id: null
            });
            return new Response(body2, { status: 400 });
          }
          sessionId = sessionId ?? namespace.newUniqueId().toString();
          const id = namespace.idFromName(`streamable-http:${sessionId}`);
          const doStub = namespace.get(id);
          const isInitialized = await doStub.isInitialized();
          if (isInitializationRequest) {
            await doStub.setInitialized();
          } else if (!isInitialized) {
            const body2 = JSON.stringify({
              jsonrpc: "2.0",
              error: {
                code: -32001,
                message: "Session not found"
              },
              id: null
            });
            return new Response(body2, { status: 404 });
          }
          const { readable, writable } = new TransformStream();
          const writer = writable.getWriter();
          const encoder = new TextEncoder();
          const upgradeUrl = new URL(request.url);
          upgradeUrl.pathname = "/streamable-http";
          const response = await doStub.fetch(
            new Request(upgradeUrl, {
              headers: {
                Upgrade: "websocket",
                // Required by PartyServer
                "x-partykit-room": sessionId
              }
            })
          );
          const ws = response.webSocket;
          if (!ws) {
            console.error("Failed to establish WebSocket connection");
            await writer.close();
            const body2 = JSON.stringify({
              jsonrpc: "2.0",
              error: {
                code: -32001,
                message: "Failed to establish WebSocket connection"
              },
              id: null
            });
            return new Response(body2, { status: 500 });
          }
          const requestIds = /* @__PURE__ */ new Set();
          ws.accept();
          ws.addEventListener("message", (event) => {
            async function onMessage(event2) {
              try {
                const data = typeof event2.data === "string" ? event2.data : new TextDecoder().decode(event2.data);
                const message = JSON.parse(data);
                const result = JSONRPCMessageSchema.safeParse(message);
                if (!result.success) {
                  return;
                }
                if (isJSONRPCResponse(result.data) || isJSONRPCError(result.data)) {
                  requestIds.delete(result.data.id);
                }
                const messageText = `event: message
data: ${JSON.stringify(result.data)}

`;
                await writer.write(encoder.encode(messageText));
                if (requestIds.size === 0) {
                  ws.close();
                }
              } catch (error) {
                console.error("Error forwarding message to SSE:", error);
              }
            }
            onMessage(event).catch(console.error);
          });
          ws.addEventListener("error", (error) => {
            async function onError(error2) {
              try {
                await writer.close();
              } catch (e) {
              }
            }
            onError(error).catch(console.error);
          });
          ws.addEventListener("close", () => {
            async function onClose() {
              try {
                await writer.close();
              } catch (error) {
                console.error("Error closing SSE connection:", error);
              }
            }
            onClose().catch(console.error);
          });
          const hasOnlyNotificationsOrResponses = messages.every(
            (msg) => isJSONRPCNotification(msg) || isJSONRPCResponse(msg)
          );
          if (hasOnlyNotificationsOrResponses) {
            for (const message of messages) {
              ws.send(JSON.stringify(message));
            }
            ws.close();
            return new Response(null, { status: 202 });
          }
          for (const message of messages) {
            if (isJSONRPCRequest(message)) {
              requestIds.add(message.id);
            }
            ws.send(JSON.stringify(message));
          }
          return new Response(readable, {
            headers: {
              "Content-Type": "text/event-stream",
              "Cache-Control": "no-cache",
              Connection: "keep-alive",
              "mcp-session-id": sessionId,
              "Access-Control-Allow-Origin": corsOptions?.origin || "*"
            },
            status: 200
          });
        }
        const body = JSON.stringify({
          jsonrpc: "2.0",
          error: {
            code: -32e3,
            message: "Method not allowed"
          },
          id: null
        });
        return new Response(body, { status: 405 });
      }
    };
  }
};
_status = new WeakMap();
_transport = new WeakMap();
_transportType = new WeakMap();
_requestIdToConnectionId = new WeakMap();
_agent = new WeakMap();
_McpAgent_instances = new WeakSet();
initialize_fn = async function() {
  await this.ctx.blockConcurrencyWhile(async () => {
    __privateSet(this, _status, "starting");
    await this.onStart();
    __privateSet(this, _status, "started");
  });
};
var McpAgent = _McpAgent;
export {
  McpAgent
};
//# sourceMappingURL=index.js.map