{"version":3,"sources":["../../src/mcp/index.ts"],"sourcesContent":["import { DurableObject } from \"cloudflare:workers\";\nimport { Agent } from \"../\";\nimport type { WSMessage } from \"../\";\nimport type { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport type { Connection } from \"../\";\nimport type {\n  JSONRPCError,\n  JSONRPCMessage,\n  JSONRPCNotification,\n  JSONRPCRequest,\n  JSONRPCResponse,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type { Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\nimport {\n  InitializeRequestSchema,\n  isJSONRPCError,\n  isJSONRPCNotification,\n  isJSONRPCRequest,\n  isJSONRPCResponse,\n  JSONRPCErrorSchema,\n  JSONRPCMessageSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCRequestSchema,\n  JSONRPCResponseSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\n\nconst MAXIMUM_MESSAGE_SIZE_BYTES = 4 * 1024 * 1024; // 4MB\n\n// CORS helper function\nfunction handleCORS(\n  request: Request,\n  corsOptions?: CORSOptions\n): Response | null {\n  const origin = request.headers.get(\"Origin\") || \"*\";\n  const corsHeaders = {\n    \"Access-Control-Allow-Origin\": corsOptions?.origin || origin,\n    \"Access-Control-Allow-Methods\":\n      corsOptions?.methods || \"GET, POST, OPTIONS\",\n    \"Access-Control-Allow-Headers\": corsOptions?.headers || \"Content-Type\",\n    \"Access-Control-Max-Age\": (corsOptions?.maxAge || 86400).toString(),\n  };\n\n  if (request.method === \"OPTIONS\") {\n    return new Response(null, { headers: corsHeaders });\n  }\n\n  return null;\n}\n\ninterface CORSOptions {\n  origin?: string;\n  methods?: string;\n  headers?: string;\n  maxAge?: number;\n}\n\nclass McpSSETransport implements Transport {\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n  sessionId?: string;\n\n  #getWebSocket: () => WebSocket | null;\n  #started = false;\n  constructor(getWebSocket: () => WebSocket | null) {\n    this.#getWebSocket = getWebSocket;\n  }\n\n  async start() {\n    // The transport does not manage the WebSocket connection since it's terminated\n    // by the Durable Object in order to allow hibernation. There's nothing to initialize.\n    if (this.#started) {\n      throw new Error(\"Transport already started\");\n    }\n    this.#started = true;\n  }\n\n  async send(message: JSONRPCMessage) {\n    if (!this.#started) {\n      throw new Error(\"Transport not started\");\n    }\n    const websocket = this.#getWebSocket();\n    if (!websocket) {\n      throw new Error(\"WebSocket not connected\");\n    }\n    try {\n      websocket.send(JSON.stringify(message));\n    } catch (error) {\n      this.onerror?.(error as Error);\n      throw error;\n    }\n  }\n\n  async close() {\n    // Similar to start, the only thing to do is to pass the event on to the server\n    this.onclose?.();\n  }\n}\n\ntype TransportType = \"sse\" | \"streamable-http\" | \"unset\";\n\nclass McpStreamableHttpTransport implements Transport {\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n  sessionId?: string;\n\n  // TODO: If there is an open connection to send server-initiated messages\n  // back, we should use that connection\n  #getWebSocketForGetRequest: () => WebSocket | null;\n\n  // Get the appropriate websocket connection for a given message id\n  #getWebSocketForMessageID: (id: string) => WebSocket | null;\n\n  // Notify the server that a response has been sent for a given message id\n  // so that it may clean up it's mapping of message ids to connections\n  // once they are no longer needed\n  #notifyResponseIdSent: (id: string) => void;\n\n  #started = false;\n  constructor(\n    getWebSocketForMessageID: (id: string) => WebSocket | null,\n    notifyResponseIdSent: (id: string | number) => void\n  ) {\n    this.#getWebSocketForMessageID = getWebSocketForMessageID;\n    this.#notifyResponseIdSent = notifyResponseIdSent;\n    // TODO\n    this.#getWebSocketForGetRequest = () => null;\n  }\n\n  async start() {\n    // The transport does not manage the WebSocket connection since it's terminated\n    // by the Durable Object in order to allow hibernation. There's nothing to initialize.\n    if (this.#started) {\n      throw new Error(\"Transport already started\");\n    }\n    this.#started = true;\n  }\n\n  async send(message: JSONRPCMessage) {\n    if (!this.#started) {\n      throw new Error(\"Transport not started\");\n    }\n\n    let websocket: WebSocket | null = null;\n\n    if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n      websocket = this.#getWebSocketForMessageID(message.id.toString());\n      if (!websocket) {\n        throw new Error(\n          `Could not find WebSocket for message id: ${message.id}`\n        );\n      }\n    } else if (isJSONRPCRequest(message)) {\n      // requests originating from the server must be sent over the\n      // the connection created by a GET request\n      websocket = this.#getWebSocketForGetRequest();\n    } else if (isJSONRPCNotification(message)) {\n      // notifications do not have an id\n      // but do have a relatedRequestId field\n      // so that they can be sent to the correct connection\n      websocket = null;\n    }\n\n    try {\n      websocket?.send(JSON.stringify(message));\n      if (isJSONRPCResponse(message)) {\n        this.#notifyResponseIdSent(message.id.toString());\n      }\n    } catch (error) {\n      this.onerror?.(error as Error);\n      throw error;\n    }\n  }\n\n  async close() {\n    // Similar to start, the only thing to do is to pass the event on to the server\n    this.onclose?.();\n  }\n}\n\ntype MaybePromise<T> = T | Promise<T>;\n\nexport abstract class McpAgent<\n  Env = unknown,\n  State = unknown,\n  Props extends Record<string, unknown> = Record<string, unknown>,\n> extends DurableObject<Env> {\n  #status: \"zero\" | \"starting\" | \"started\" = \"zero\";\n  #transport?: Transport;\n  #transportType: TransportType = \"unset\";\n  #requestIdToConnectionId: Map<string | number, string> = new Map();\n\n  /**\n   * Since McpAgent's _aren't_ yet real \"Agents\", let's only expose a couple of the methods\n   * to the outer class: initialState/state/setState/onStateUpdate/sql\n   */\n  #agent: Agent<Env, State>;\n\n  get mcp() {\n    return this.#agent.mcp;\n  }\n\n  protected constructor(ctx: DurableObjectState, env: Env) {\n    super(ctx, env);\n    const self = this;\n\n    this.#agent = new (class extends Agent<Env, State> {\n      static options = {\n        hibernate: true,\n      };\n\n      onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n        return self.onStateUpdate(state, source);\n      }\n\n      async onMessage(\n        connection: Connection,\n        message: WSMessage\n      ): Promise<void> {\n        return self.onMessage(connection, message);\n      }\n    })(ctx, env);\n  }\n\n  /**\n   * Agents API allowlist\n   */\n  initialState!: State;\n  get state() {\n    return this.#agent.state;\n  }\n  sql<T = Record<string, string | number | boolean | null>>(\n    strings: TemplateStringsArray,\n    ...values: (string | number | boolean | null)[]\n  ) {\n    return this.#agent.sql<T>(strings, ...values);\n  }\n\n  setState(state: State) {\n    return this.#agent.setState(state);\n  }\n  onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n    // override this to handle state updates\n  }\n  async onStart() {\n    const self = this;\n\n    this.#agent = new (class extends Agent<Env, State> {\n      initialState: State = self.initialState;\n      static options = {\n        hibernate: true,\n      };\n\n      onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n        return self.onStateUpdate(state, source);\n      }\n\n      async onMessage(connection: Connection, event: WSMessage) {\n        return self.onMessage(connection, event);\n      }\n    })(this.ctx, this.env);\n\n    this.props = (await this.ctx.storage.get(\"props\")) as Props;\n    this.#transportType = (await this.ctx.storage.get(\n      \"transportType\"\n    )) as TransportType;\n    await this._init(this.props);\n\n    const server = await this.server;\n\n    // Connect to the MCP server\n    if (this.#transportType === \"sse\") {\n      this.#transport = new McpSSETransport(() => this.getWebSocket());\n      await server.connect(this.#transport);\n    } else if (this.#transportType === \"streamable-http\") {\n      this.#transport = new McpStreamableHttpTransport(\n        (id) => this.getWebSocketForResponseID(id),\n        (id) => this.#requestIdToConnectionId.delete(id)\n      );\n      await server.connect(this.#transport);\n    }\n  }\n\n  /**\n   * McpAgent API\n   */\n  abstract server: MaybePromise<McpServer | Server>;\n  props!: Props;\n  initRun = false;\n\n  abstract init(): Promise<void>;\n\n  async _init(props: Props) {\n    await this.ctx.storage.put(\"props\", props ?? {});\n    if (!this.ctx.storage.get(\"transportType\")) {\n      await this.ctx.storage.put(\"transportType\", \"unset\");\n    }\n    this.props = props;\n    if (!this.initRun) {\n      this.initRun = true;\n      await this.init();\n    }\n  }\n\n  async setInitialized() {\n    await this.ctx.storage.put(\"initialized\", true);\n  }\n\n  async isInitialized() {\n    return (await this.ctx.storage.get(\"initialized\")) === true;\n  }\n\n  async #initialize(): Promise<void> {\n    await this.ctx.blockConcurrencyWhile(async () => {\n      this.#status = \"starting\";\n      await this.onStart();\n      this.#status = \"started\";\n    });\n  }\n\n  // Allow the worker to fetch a websocket connection to the agent\n  async fetch(request: Request): Promise<Response> {\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n\n    // Only handle WebSocket upgrade requests\n    if (request.headers.get(\"Upgrade\") !== \"websocket\") {\n      return new Response(\"Expected WebSocket Upgrade request\", {\n        status: 400,\n      });\n    }\n\n    // This request does not come from the user. The worker generates this\n    // request to generate a websocket connection to the agent.\n    const url = new URL(request.url);\n    // This is not the path that the user requested, but the path that the worker\n    // generated. We'll use this path to determine which transport to use.\n    const path = url.pathname;\n    const server = await this.server;\n\n    switch (path) {\n      case \"/sse\": {\n        // For SSE connections, we can only have one open connection per session\n        // If we get an upgrade while already connected, we should error\n        const websockets = this.ctx.getWebSockets();\n        if (websockets.length > 0) {\n          return new Response(\"Websocket already connected\", { status: 400 });\n        }\n\n        // This session must always use the SSE transporo\n        await this.ctx.storage.put(\"transportType\", \"sse\");\n        this.#transportType = \"sse\";\n\n        if (!this.#transport) {\n          this.#transport = new McpSSETransport(() => this.getWebSocket());\n          await server.connect(this.#transport);\n        }\n\n        // Defer to the Agent's fetch method to handle the WebSocket connection\n        return this.#agent.fetch(request);\n      }\n      case \"/streamable-http\": {\n        if (!this.#transport) {\n          this.#transport = new McpStreamableHttpTransport(\n            (id) => this.getWebSocketForResponseID(id),\n            (id) => this.#requestIdToConnectionId.delete(id)\n          );\n          await server.connect(this.#transport);\n        }\n\n        // This session must always use the streamable-http transport\n        await this.ctx.storage.put(\"transportType\", \"streamable-http\");\n        this.#transportType = \"streamable-http\";\n\n        return this.#agent.fetch(request);\n      }\n      default:\n        return new Response(\n          \"Internal Server Error: Expected /sse or /streamable-http path\",\n          {\n            status: 500,\n          }\n        );\n    }\n  }\n\n  getWebSocket() {\n    const websockets = this.ctx.getWebSockets();\n    if (websockets.length === 0) {\n      return null;\n    }\n    return websockets[0];\n  }\n\n  getWebSocketForResponseID(id: string): WebSocket | null {\n    const connectionId = this.#requestIdToConnectionId.get(id);\n    if (connectionId === undefined) {\n      return null;\n    }\n    return this.#agent.getConnection(connectionId) ?? null;\n  }\n\n  // All messages received here. This is currently never called\n  async onMessage(connection: Connection, event: WSMessage) {\n    // Since we address the DO via both the protocol and the session id,\n    // this should never happen, but let's enforce it just in case\n    if (this.#transportType !== \"streamable-http\") {\n      const err = new Error(\n        \"Internal Server Error: Expected streamable-http protocol\"\n      );\n      this.#transport?.onerror?.(err);\n      return;\n    }\n\n    let message: JSONRPCMessage;\n    try {\n      // Ensure event is a string\n      const data =\n        typeof event === \"string\" ? event : new TextDecoder().decode(event);\n      message = JSONRPCMessageSchema.parse(JSON.parse(data));\n    } catch (error) {\n      this.#transport?.onerror?.(error as Error);\n      return;\n    }\n\n    // We need to map every incoming message to the connection that it came in on\n    // so that we can send relevant responses and notifications back on the same connection\n    if (isJSONRPCRequest(message)) {\n      this.#requestIdToConnectionId.set(message.id.toString(), connection.id);\n    }\n\n    this.#transport?.onmessage?.(message);\n  }\n\n  // All messages received over SSE after the initial connection has been established\n  // will be passed here\n  async onSSEMcpMessage(\n    sessionId: string,\n    request: Request\n  ): Promise<Error | null> {\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n\n    // Since we address the DO via both the protocol and the session id,\n    // this should never happen, but let's enforce it just in case\n    if (this.#transportType !== \"sse\") {\n      return new Error(\"Internal Server Error: Expected SSE protocol\");\n    }\n\n    try {\n      const message = await request.json();\n      let parsedMessage: JSONRPCMessage;\n      try {\n        parsedMessage = JSONRPCMessageSchema.parse(message);\n      } catch (error) {\n        this.#transport?.onerror?.(error as Error);\n        throw error;\n      }\n\n      this.#transport?.onmessage?.(parsedMessage);\n      return null;\n    } catch (error) {\n      this.#transport?.onerror?.(error as Error);\n      return error as Error;\n    }\n  }\n\n  // Delegate all websocket events to the underlying agent\n  async webSocketMessage(\n    ws: WebSocket,\n    event: ArrayBuffer | string\n  ): Promise<void> {\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    return await this.#agent.webSocketMessage(ws, event);\n  }\n\n  // WebSocket event handlers for hibernation support\n  async webSocketError(ws: WebSocket, error: unknown): Promise<void> {\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    return await this.#agent.webSocketError(ws, error);\n  }\n\n  async webSocketClose(\n    ws: WebSocket,\n    code: number,\n    reason: string,\n    wasClean: boolean\n  ): Promise<void> {\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    return await this.#agent.webSocketClose(ws, code, reason, wasClean);\n  }\n\n  static mount(\n    path: string,\n    {\n      binding = \"MCP_OBJECT\",\n      corsOptions,\n    }: {\n      binding?: string;\n      corsOptions?: CORSOptions;\n    } = {}\n  ) {\n    return McpAgent.serveSSE(path, { binding, corsOptions });\n  }\n\n  static serveSSE(\n    path: string,\n    {\n      binding = \"MCP_OBJECT\",\n      corsOptions,\n    }: {\n      binding?: string;\n      corsOptions?: CORSOptions;\n    } = {}\n  ) {\n    let pathname = path;\n    if (path === \"/\") {\n      pathname = \"/*\";\n    }\n    const basePattern = new URLPattern({ pathname });\n    const messagePattern = new URLPattern({ pathname: `${pathname}/message` });\n\n    return {\n      async fetch<Env>(\n        request: Request,\n        env: Env,\n        ctx: ExecutionContext\n      ): Promise<Response> {\n        // Handle CORS preflight\n        const corsResponse = handleCORS(request, corsOptions);\n        if (corsResponse) return corsResponse;\n\n        const url = new URL(request.url);\n        const bindingValue = env[binding as keyof typeof env] as unknown;\n\n        // Ensure we have a binding of some sort\n        if (bindingValue == null || typeof bindingValue !== \"object\") {\n          console.error(\n            `Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`\n          );\n          return new Response(\"Invalid binding\", { status: 500 });\n        }\n\n        // Ensure that the biding is to a DurableObject\n        if (bindingValue.toString() !== \"[object DurableObjectNamespace]\") {\n          return new Response(\"Invalid binding\", { status: 500 });\n        }\n\n        const namespace = bindingValue as DurableObjectNamespace<McpAgent>;\n\n        // Handle initial SSE connection\n        if (request.method === \"GET\" && basePattern.test(url)) {\n          // Use a session ID if one is passed in, or create a unique\n          // session ID for this connection\n          const sessionId =\n            url.searchParams.get(\"sessionId\") ||\n            namespace.newUniqueId().toString();\n\n          // Create a Transform Stream for SSE\n          const { readable, writable } = new TransformStream();\n          const writer = writable.getWriter();\n          const encoder = new TextEncoder();\n\n          // Send the endpoint event\n          const endpointUrl = new URL(request.url);\n          endpointUrl.pathname = encodeURI(`${pathname}/message`);\n          endpointUrl.searchParams.set(\"sessionId\", sessionId);\n          const relativeUrlWithSession =\n            endpointUrl.pathname + endpointUrl.search + endpointUrl.hash;\n          const endpointMessage = `event: endpoint\\ndata: ${relativeUrlWithSession}\\n\\n`;\n          writer.write(encoder.encode(endpointMessage));\n\n          // Get the Durable Object\n          const id = namespace.idFromName(`sse:${sessionId}`);\n          const doStub = namespace.get(id);\n\n          // Initialize the object\n          await doStub._init(ctx.props);\n\n          // Connect to the Durable Object via WebSocket\n          const upgradeUrl = new URL(request.url);\n          // enforce that the path that the DO receives is always /sse\n          upgradeUrl.pathname = \"/sse\";\n          const response = await doStub.fetch(\n            new Request(upgradeUrl, {\n              headers: {\n                Upgrade: \"websocket\",\n                // Required by PartyServer\n                \"x-partykit-room\": sessionId,\n              },\n            })\n          );\n\n          // Get the WebSocket\n          const ws = response.webSocket;\n          if (!ws) {\n            console.error(\"Failed to establish WebSocket connection\");\n            await writer.close();\n            return new Response(\"Failed to establish WebSocket connection\", {\n              status: 500,\n            });\n          }\n\n          // Accept the WebSocket\n          ws.accept();\n\n          // Handle messages from the Durable Object\n          ws.addEventListener(\"message\", (event) => {\n            async function onMessage(event: MessageEvent) {\n              try {\n                const message = JSON.parse(event.data);\n\n                // validate that the message is a valid JSONRPC message\n                const result = JSONRPCMessageSchema.safeParse(message);\n                if (!result.success) {\n                  // The message was not a valid JSONRPC message, so we will drop it\n                  // PartyKit will broadcast state change messages to all connected clients\n                  // and we need to filter those out so they are not passed to MCP clients\n                  return;\n                }\n\n                // Send the message as an SSE event\n                const messageText = `event: message\\ndata: ${JSON.stringify(result.data)}\\n\\n`;\n                await writer.write(encoder.encode(messageText));\n              } catch (error) {\n                console.error(\"Error forwarding message to SSE:\", error);\n              }\n            }\n            onMessage(event).catch(console.error);\n          });\n\n          // Handle WebSocket errors\n          ws.addEventListener(\"error\", (error) => {\n            async function onError(error: Event) {\n              try {\n                await writer.close();\n              } catch (e) {\n                // Ignore errors when closing\n              }\n            }\n            onError(error).catch(console.error);\n          });\n\n          // Handle WebSocket closure\n          ws.addEventListener(\"close\", () => {\n            async function onClose() {\n              try {\n                await writer.close();\n              } catch (error) {\n                console.error(\"Error closing SSE connection:\", error);\n              }\n            }\n            onClose().catch(console.error);\n          });\n\n          // Return the SSE response\n          return new Response(readable, {\n            headers: {\n              \"Content-Type\": \"text/event-stream\",\n              \"Cache-Control\": \"no-cache\",\n              Connection: \"keep-alive\",\n              \"Access-Control-Allow-Origin\": corsOptions?.origin || \"*\",\n            },\n          });\n        }\n\n        // Handle incoming MCP messages. These will be passed to McpAgent\n        // but the response will be sent back via the open SSE connection\n        // so we only need to return a 202 Accepted response for success\n        if (request.method === \"POST\" && messagePattern.test(url)) {\n          const sessionId = url.searchParams.get(\"sessionId\");\n          if (!sessionId) {\n            return new Response(\n              `Missing sessionId. Expected POST to ${pathname} to initiate new one`,\n              { status: 400 }\n            );\n          }\n\n          const contentType = request.headers.get(\"content-type\") || \"\";\n          if (!contentType.includes(\"application/json\")) {\n            return new Response(`Unsupported content-type: ${contentType}`, {\n              status: 400,\n            });\n          }\n\n          // check if the request body is too large\n          const contentLength = Number.parseInt(\n            request.headers.get(\"content-length\") || \"0\",\n            10\n          );\n          if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {\n            return new Response(\n              `Request body too large: ${contentLength} bytes`,\n              {\n                status: 400,\n              }\n            );\n          }\n\n          // Get the Durable Object\n          const id = namespace.idFromName(`sse:${sessionId}`);\n          const doStub = namespace.get(id);\n\n          // Forward the request to the Durable Object\n          const error = await doStub.onSSEMcpMessage(sessionId, request);\n\n          if (error) {\n            return new Response(error.message, {\n              status: 400,\n              headers: {\n                \"Content-Type\": \"text/event-stream\",\n                \"Cache-Control\": \"no-cache\",\n                Connection: \"keep-alive\",\n                \"Access-Control-Allow-Origin\": corsOptions?.origin || \"*\",\n              },\n            });\n          }\n\n          return new Response(\"Accepted\", {\n            status: 202,\n            headers: {\n              \"Content-Type\": \"text/event-stream\",\n              \"Cache-Control\": \"no-cache\",\n              Connection: \"keep-alive\",\n              \"Access-Control-Allow-Origin\": corsOptions?.origin || \"*\",\n            },\n          });\n        }\n\n        return new Response(\"Not Found\", { status: 404 });\n      },\n    };\n  }\n\n  static serve(\n    path: string,\n    {\n      binding = \"MCP_OBJECT\",\n      corsOptions,\n    }: { binding?: string; corsOptions?: CORSOptions } = {}\n  ) {\n    let pathname = path;\n    if (path === \"/\") {\n      pathname = \"/*\";\n    }\n    const basePattern = new URLPattern({ pathname });\n\n    return {\n      async fetch<Env>(\n        request: Request,\n        env: Env,\n        ctx: ExecutionContext\n      ): Promise<Response> {\n        // Handle CORS preflight\n        const corsResponse = handleCORS(request, corsOptions);\n        if (corsResponse) {\n          return corsResponse;\n        }\n\n        const url = new URL(request.url);\n        const bindingValue = env[binding as keyof typeof env] as unknown;\n\n        // Ensure we have a binding of some sort\n        if (bindingValue == null || typeof bindingValue !== \"object\") {\n          console.error(\n            `Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`\n          );\n          return new Response(\"Invalid binding\", { status: 500 });\n        }\n\n        // Ensure that the biding is to a DurableObject\n        if (bindingValue.toString() !== \"[object DurableObjectNamespace]\") {\n          return new Response(\"Invalid binding\", { status: 500 });\n        }\n\n        const namespace = bindingValue as DurableObjectNamespace<McpAgent>;\n\n        if (request.method === \"POST\" && basePattern.test(url)) {\n          // validate the Accept header\n          const acceptHeader = request.headers.get(\"accept\");\n          // The client MUST include an Accept header, listing both application/json and text/event-stream as supported content types.\n          if (\n            !acceptHeader?.includes(\"application/json\") ||\n            !acceptHeader.includes(\"text/event-stream\")\n          ) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32000,\n                message:\n                  \"Not Acceptable: Client must accept both application/json and text/event-stream\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 406 });\n          }\n\n          const ct = request.headers.get(\"content-type\");\n          if (!ct || !ct.includes(\"application/json\")) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32000,\n                message:\n                  \"Unsupported Media Type: Content-Type must be application/json\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 415 });\n          }\n\n          // Check content length against maximum allowed size\n          const contentLength = Number.parseInt(\n            request.headers.get(\"content-length\") ?? \"0\",\n            10\n          );\n          if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32000,\n                message: `Request body too large. Maximum size is ${MAXIMUM_MESSAGE_SIZE_BYTES} bytes`,\n              },\n              id: null,\n            });\n            return new Response(body, { status: 413 });\n          }\n\n          let sessionId = request.headers.get(\"mcp-session-id\");\n          let rawMessage: unknown;\n\n          try {\n            rawMessage = await request.json();\n          } catch (error) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32700,\n                message: \"Parse error: Invalid JSON\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 400 });\n          }\n\n          // Make sure the message is an array to simplify logic\n          let arrayMessage: unknown[];\n          if (Array.isArray(rawMessage)) {\n            arrayMessage = rawMessage;\n          } else {\n            arrayMessage = [rawMessage];\n          }\n\n          let messages: JSONRPCMessage[] = [];\n\n          // Try to parse each message as JSON RPC. Fail if any message is invalid\n          for (const msg of arrayMessage) {\n            if (!JSONRPCMessageSchema.safeParse(msg).success) {\n              const body = JSON.stringify({\n                jsonrpc: \"2.0\",\n                error: {\n                  code: -32700,\n                  message: \"Parse error: Invalid JSON-RPC message\",\n                },\n                id: null,\n              });\n              return new Response(body, { status: 400 });\n            }\n          }\n\n          messages = arrayMessage.map((msg) => JSONRPCMessageSchema.parse(msg));\n\n          // Before we pass the messages to the agent, there's another error condition we need to enforce\n          // Check if this is an initialization request\n          // https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/lifecycle/\n          const isInitializationRequest = messages.some(\n            (msg) => InitializeRequestSchema.safeParse(msg).success\n          );\n\n          if (isInitializationRequest && sessionId) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32600,\n                message:\n                  \"Invalid Request: Initialization requests must not include a sessionId\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 400 });\n          }\n\n          // The initialization request must be the only request in the batch\n          if (isInitializationRequest && messages.length > 1) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32600,\n                message:\n                  \"Invalid Request: Only one initialization request is allowed\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 400 });\n          }\n\n          // If an Mcp-Session-Id is returned by the server during initialization,\n          // clients using the Streamable HTTP transport MUST include it\n          // in the Mcp-Session-Id header on all of their subsequent HTTP requests.\n          if (!isInitializationRequest && !sessionId) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32000,\n                message: \"Bad Request: Mcp-Session-Id header is required\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 400 });\n          }\n\n          // If we don't have a sessionId, we are serving an initialization request\n          // and need to generate a new sessionId\n          sessionId = sessionId ?? namespace.newUniqueId().toString();\n\n          // fetch the agent DO\n          const id = namespace.idFromName(`streamable-http:${sessionId}`);\n          const doStub = namespace.get(id);\n          const isInitialized = await doStub.isInitialized();\n\n          if (isInitializationRequest) {\n            await doStub.setInitialized();\n          } else if (!isInitialized) {\n            // if we have gotten here, then a session id that was never initialized\n            // was provided\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32001,\n                message: \"Session not found\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 404 });\n          }\n\n          // We've evaluated all the error conditions! Now it's time to establish\n          // all the streams\n\n          // Create a Transform Stream for SSE\n          const { readable, writable } = new TransformStream();\n          const writer = writable.getWriter();\n          const encoder = new TextEncoder();\n\n          // Connect to the Durable Object via WebSocket\n          const upgradeUrl = new URL(request.url);\n          upgradeUrl.pathname = \"/streamable-http\";\n          const response = await doStub.fetch(\n            new Request(upgradeUrl, {\n              headers: {\n                Upgrade: \"websocket\",\n                // Required by PartyServer\n                \"x-partykit-room\": sessionId,\n              },\n            })\n          );\n\n          // Get the WebSocket\n          const ws = response.webSocket;\n          if (!ws) {\n            console.error(\"Failed to establish WebSocket connection\");\n\n            await writer.close();\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32001,\n                message: \"Failed to establish WebSocket connection\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 500 });\n          }\n\n          // Keep track of the request ids that we have sent to the server\n          // so that we can close the connection once we have received\n          // all the responses\n          const requestIds: Set<string | number> = new Set();\n\n          // Accept the WebSocket\n          ws.accept();\n\n          // Handle messages from the Durable Object\n          ws.addEventListener(\"message\", (event) => {\n            async function onMessage(event: MessageEvent) {\n              try {\n                const data =\n                  typeof event.data === \"string\"\n                    ? event.data\n                    : new TextDecoder().decode(event.data);\n                const message = JSON.parse(data);\n\n                // validate that the message is a valid JSONRPC message\n                const result = JSONRPCMessageSchema.safeParse(message);\n                if (!result.success) {\n                  // The message was not a valid JSONRPC message, so we will drop it\n                  // PartyKit will broadcast state change messages to all connected clients\n                  // and we need to filter those out so they are not passed to MCP clients\n                  return;\n                }\n\n                // If the message is a response or an error, remove the id from the set of\n                // request ids\n                if (\n                  isJSONRPCResponse(result.data) ||\n                  isJSONRPCError(result.data)\n                ) {\n                  requestIds.delete(result.data.id);\n                }\n\n                // Send the message as an SSE event\n                const messageText = `event: message\\ndata: ${JSON.stringify(result.data)}\\n\\n`;\n                await writer.write(encoder.encode(messageText));\n\n                // If we have received all the responses, close the connection\n                if (requestIds.size === 0) {\n                  ws!.close();\n                }\n              } catch (error) {\n                console.error(\"Error forwarding message to SSE:\", error);\n              }\n            }\n            onMessage(event).catch(console.error);\n          });\n\n          // Handle WebSocket errors\n          ws.addEventListener(\"error\", (error) => {\n            async function onError(error: Event) {\n              try {\n                await writer.close();\n              } catch (e) {\n                // Ignore errors when closing\n              }\n            }\n            onError(error).catch(console.error);\n          });\n\n          // Handle WebSocket closure\n          ws.addEventListener(\"close\", () => {\n            async function onClose() {\n              try {\n                await writer.close();\n              } catch (error) {\n                console.error(\"Error closing SSE connection:\", error);\n              }\n            }\n            onClose().catch(console.error);\n          });\n\n          // If there are no requests, we send the messages to the agent and acknowledge the request with a 202\n          // since we don't expect any responses back through this connection\n          const hasOnlyNotificationsOrResponses = messages.every(\n            (msg) => isJSONRPCNotification(msg) || isJSONRPCResponse(msg)\n          );\n          if (hasOnlyNotificationsOrResponses) {\n            for (const message of messages) {\n              ws.send(JSON.stringify(message));\n            }\n\n            // closing the websocket will also close the SSE connection\n            ws.close();\n\n            return new Response(null, { status: 202 });\n          }\n\n          for (const message of messages) {\n            if (isJSONRPCRequest(message)) {\n              // add each request id that we send off to a set\n              // so that we can keep track of which requests we\n              // still need a response for\n              requestIds.add(message.id);\n            }\n            ws.send(JSON.stringify(message));\n          }\n\n          // Return the SSE response. We handle closing the stream in the ws \"message\"\n          // handler\n          return new Response(readable, {\n            headers: {\n              \"Content-Type\": \"text/event-stream\",\n              \"Cache-Control\": \"no-cache\",\n              Connection: \"keep-alive\",\n              \"mcp-session-id\": sessionId,\n              \"Access-Control-Allow-Origin\": corsOptions?.origin || \"*\",\n            },\n            status: 200,\n          });\n        }\n\n        // We don't yet support GET or DELETE requests\n        const body = JSON.stringify({\n          jsonrpc: \"2.0\",\n          error: {\n            code: -32000,\n            message: \"Method not allowed\",\n          },\n          id: null,\n        });\n        return new Response(body, { status: 405 });\n      },\n    };\n  }\n}\n"],"mappings":"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","names":["_started","event","error","body"]}