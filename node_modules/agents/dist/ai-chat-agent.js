import {
  Agent
} from "./chunk-A65CRW2D.js";
import "./chunk-Q5ZBHY4Z.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet
} from "./chunk-HMLY7DHA.js";

// src/ai-chat-agent.ts
import { appendResponseMessages } from "ai";
var decoder = new TextDecoder();
var _chatMessageAbortControllers, _AIChatAgent_instances, broadcastChatMessage_fn, tryCatch_fn, reply_fn, getAbortSignal_fn, removeAbortController_fn, cancelChatRequest_fn, destroyAbortControllers_fn;
var AIChatAgent = class extends Agent {
  constructor(ctx, env) {
    super(ctx, env);
    __privateAdd(this, _AIChatAgent_instances);
    /**
     * Map of message `id`s to `AbortController`s
     * useful to propagate request cancellation signals for any external calls made by the agent
     */
    __privateAdd(this, _chatMessageAbortControllers);
    this.sql`create table if not exists cf_ai_chat_agent_messages (
      id text primary key,
      message text not null,
      created_at datetime default current_timestamp
    )`;
    this.messages = (this.sql`select * from cf_ai_chat_agent_messages` || []).map((row) => {
      return JSON.parse(row.message);
    });
    __privateSet(this, _chatMessageAbortControllers, /* @__PURE__ */ new Map());
  }
  async onMessage(connection, message) {
    if (typeof message === "string") {
      let data;
      try {
        data = JSON.parse(message);
      } catch (error) {
        return;
      }
      if (data.type === "cf_agent_use_chat_request" && data.init.method === "POST") {
        const {
          method,
          keepalive,
          headers,
          body,
          // we're reading this
          redirect,
          integrity,
          credentials,
          mode,
          referrer,
          referrerPolicy,
          window
          // dispatcher,
          // duplex
        } = data.init;
        const { messages } = JSON.parse(body);
        __privateMethod(this, _AIChatAgent_instances, broadcastChatMessage_fn).call(this, {
          type: "cf_agent_chat_messages",
          messages
        }, [connection.id]);
        await this.persistMessages(messages, [connection.id]);
        const chatMessageId = data.id;
        const abortSignal = __privateMethod(this, _AIChatAgent_instances, getAbortSignal_fn).call(this, chatMessageId);
        return __privateMethod(this, _AIChatAgent_instances, tryCatch_fn).call(this, async () => {
          const response = await this.onChatMessage(
            async ({ response: response2 }) => {
              const finalMessages = appendResponseMessages({
                messages,
                responseMessages: response2.messages
              });
              await this.persistMessages(finalMessages, [connection.id]);
              __privateMethod(this, _AIChatAgent_instances, removeAbortController_fn).call(this, chatMessageId);
            },
            abortSignal ? { abortSignal } : void 0
          );
          if (response) {
            await __privateMethod(this, _AIChatAgent_instances, reply_fn).call(this, data.id, response);
          }
        });
      }
      if (data.type === "cf_agent_chat_clear") {
        __privateMethod(this, _AIChatAgent_instances, destroyAbortControllers_fn).call(this);
        this.sql`delete from cf_ai_chat_agent_messages`;
        this.messages = [];
        __privateMethod(this, _AIChatAgent_instances, broadcastChatMessage_fn).call(this, {
          type: "cf_agent_chat_clear"
        }, [connection.id]);
      } else if (data.type === "cf_agent_chat_messages") {
        await this.persistMessages(data.messages, [connection.id]);
      } else if (data.type === "cf_agent_chat_request_cancel") {
        __privateMethod(this, _AIChatAgent_instances, cancelChatRequest_fn).call(this, data.id);
      }
    }
  }
  async onRequest(request) {
    return __privateMethod(this, _AIChatAgent_instances, tryCatch_fn).call(this, () => {
      const url = new URL(request.url);
      if (url.pathname.endsWith("/get-messages")) {
        const messages = (this.sql`select * from cf_ai_chat_agent_messages` || []).map((row) => {
          return JSON.parse(row.message);
        });
        return Response.json(messages);
      }
      return super.onRequest(request);
    });
  }
  /**
   * Handle incoming chat messages and generate a response
   * @param onFinish Callback to be called when the response is finished
   * @param options.signal A signal to pass to any child requests which can be used to cancel them
   * @returns Response to send to the client or undefined
   */
  async onChatMessage(onFinish, options) {
    throw new Error(
      "recieved a chat message, override onChatMessage and return a Response to send to the client"
    );
  }
  /**
   * Save messages on the server side and trigger AI response
   * @param messages Chat messages to save
   */
  async saveMessages(messages) {
    await this.persistMessages(messages);
    const response = await this.onChatMessage(async ({ response: response2 }) => {
      const finalMessages = appendResponseMessages({
        messages,
        responseMessages: response2.messages
      });
      await this.persistMessages(finalMessages, []);
    });
    if (response) {
      for await (const chunk of response.body) {
        decoder.decode(chunk);
      }
      response.body?.cancel();
    }
  }
  async persistMessages(messages, excludeBroadcastIds = []) {
    this.sql`delete from cf_ai_chat_agent_messages`;
    for (const message of messages) {
      this.sql`insert into cf_ai_chat_agent_messages (id, message) values (${message.id},${JSON.stringify(message)})`;
    }
    this.messages = messages;
    __privateMethod(this, _AIChatAgent_instances, broadcastChatMessage_fn).call(this, {
      type: "cf_agent_chat_messages",
      messages
    }, excludeBroadcastIds);
  }
  /**
   * When the DO is destroyed, cancel all pending requests
   */
  async destroy() {
    __privateMethod(this, _AIChatAgent_instances, destroyAbortControllers_fn).call(this);
    await super.destroy();
  }
};
_chatMessageAbortControllers = new WeakMap();
_AIChatAgent_instances = new WeakSet();
broadcastChatMessage_fn = function(message, exclude) {
  this.broadcast(JSON.stringify(message), exclude);
};
tryCatch_fn = async function(fn) {
  try {
    return await fn();
  } catch (e) {
    throw this.onError(e);
  }
};
reply_fn = async function(id, response) {
  return __privateMethod(this, _AIChatAgent_instances, tryCatch_fn).call(this, async () => {
    for await (const chunk of response.body) {
      const body = decoder.decode(chunk);
      __privateMethod(this, _AIChatAgent_instances, broadcastChatMessage_fn).call(this, {
        id,
        type: "cf_agent_use_chat_response",
        body,
        done: false
      });
    }
    __privateMethod(this, _AIChatAgent_instances, broadcastChatMessage_fn).call(this, {
      id,
      type: "cf_agent_use_chat_response",
      body: "",
      done: true
    });
  });
};
/**
 * For the given message id, look up its associated AbortController
 * If the AbortController does not exist, create and store one in memory
 *
 * returns the AbortSignal associated with the AbortController
 */
getAbortSignal_fn = function(id) {
  if (typeof id !== "string") {
    return void 0;
  }
  if (!__privateGet(this, _chatMessageAbortControllers).has(id)) {
    __privateGet(this, _chatMessageAbortControllers).set(id, new AbortController());
  }
  return __privateGet(this, _chatMessageAbortControllers).get(id)?.signal;
};
/**
 * Remove an abort controller from the cache of pending message responses
 */
removeAbortController_fn = function(id) {
  __privateGet(this, _chatMessageAbortControllers).delete(id);
};
/**
 * Propagate an abort signal for any requests associated with the given message id
 */
cancelChatRequest_fn = function(id) {
  if (__privateGet(this, _chatMessageAbortControllers).has(id)) {
    const abortController = __privateGet(this, _chatMessageAbortControllers).get(id);
    abortController?.abort();
  }
};
/**
 * Abort all pending requests and clear the cache of AbortControllers
 */
destroyAbortControllers_fn = function() {
  for (const controller of __privateGet(this, _chatMessageAbortControllers).values()) {
    controller?.abort();
  }
  __privateGet(this, _chatMessageAbortControllers).clear();
};
export {
  AIChatAgent
};
//# sourceMappingURL=ai-chat-agent.js.map