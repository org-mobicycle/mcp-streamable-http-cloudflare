{"version":3,"sources":["../src/mcp/sse-edge.ts","../src/mcp/client-connection.ts","../src/mcp/client.ts"],"sourcesContent":["import {\n  SSEClientTransport,\n  type SSEClientTransportOptions,\n} from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport type { OAuthClientProvider } from \"@modelcontextprotocol/sdk/client/auth.js\";\n\nexport class SSEEdgeClientTransport extends SSEClientTransport {\n  private authProvider: OAuthClientProvider | undefined;\n  /**\n   * Creates a new EdgeSSEClientTransport, which overrides fetch to be compatible with the CF workers environment\n   */\n  constructor(url: URL, options: SSEClientTransportOptions) {\n    const fetchOverride: typeof fetch = async (\n      fetchUrl: RequestInfo | URL,\n      fetchInit: RequestInit = {}\n    ) => {\n      // add auth headers\n      const headers = await this.authHeaders();\n      const workerOptions = {\n        ...fetchInit,\n        headers: {\n          ...fetchInit?.headers,\n          ...headers,\n        },\n      };\n\n      // Remove unsupported properties\n      // biome-ignore lint/performance/noDelete: workaround for workers environment\n      delete workerOptions.mode;\n\n      // Call the original fetch with fixed options\n      return fetch(fetchUrl, workerOptions);\n    };\n\n    super(url, {\n      ...options,\n      eventSourceInit: {\n        fetch: fetchOverride,\n      },\n    });\n    this.authProvider = options.authProvider;\n  }\n\n  async authHeaders() {\n    if (this.authProvider) {\n      const tokens = await this.authProvider.tokens();\n      if (tokens) {\n        return {\n          Authorization: `Bearer ${tokens.access_token}`,\n        };\n      }\n    }\n  }\n}\n","import { SSEEdgeClientTransport } from \"./sse-edge\";\n\nimport {\n  ToolListChangedNotificationSchema,\n  type ClientCapabilities,\n  type Resource,\n  type Tool,\n  type Prompt,\n  ResourceListChangedNotificationSchema,\n  PromptListChangedNotificationSchema,\n  type ListToolsResult,\n  type ListResourcesResult,\n  type ListPromptsResult,\n  type ServerCapabilities,\n  type ResourceTemplate,\n  type ListResourceTemplatesResult,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type { SSEClientTransportOptions } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport type { AgentsOAuthProvider } from \"./do-oauth-client-provider\";\n\nexport class MCPClientConnection {\n  client: Client;\n  connectionState:\n    | \"authenticating\"\n    | \"connecting\"\n    | \"ready\"\n    | \"discovering\"\n    | \"failed\" = \"connecting\";\n  instructions?: string;\n  tools: Tool[] = [];\n  prompts: Prompt[] = [];\n  resources: Resource[] = [];\n  resourceTemplates: ResourceTemplate[] = [];\n  serverCapabilities: ServerCapabilities | undefined;\n\n  constructor(\n    public url: URL,\n    info: ConstructorParameters<typeof Client>[0],\n    public options: {\n      transport: SSEClientTransportOptions & {\n        authProvider?: AgentsOAuthProvider;\n      };\n      client: ConstructorParameters<typeof Client>[1];\n      capabilities: ClientCapabilities;\n    } = { transport: {}, client: {}, capabilities: {} }\n  ) {\n    this.client = new Client(info, options.client);\n    this.client.registerCapabilities(options.capabilities);\n  }\n\n  /**\n   * Initialize a client connection\n   *\n   * @param code Optional OAuth code to initialize the connection with if auth hasn't been initialized\n   * @returns\n   */\n  async init(code?: string, clientId?: string) {\n    try {\n      const transport = new SSEEdgeClientTransport(\n        this.url,\n        this.options.transport\n      );\n      if (code) {\n        await transport.finishAuth(code);\n      }\n\n      await this.client.connect(transport);\n      // biome-ignore lint/suspicious/noExplicitAny: allow for the error check here\n    } catch (e: any) {\n      if (e.toString().includes(\"Unauthorized\")) {\n        // unauthorized, we should wait for the user to authenticate\n        this.connectionState = \"authenticating\";\n        return;\n      }\n      this.connectionState = \"failed\";\n      throw e;\n    }\n\n    this.connectionState = \"discovering\";\n\n    this.serverCapabilities = await this.client.getServerCapabilities();\n    if (!this.serverCapabilities) {\n      throw new Error(\"The MCP Server failed to return server capabilities\");\n    }\n\n    const [instructions, tools, resources, prompts, resourceTemplates] =\n      await Promise.all([\n        this.client.getInstructions(),\n        this.registerTools(),\n        this.registerResources(),\n        this.registerPrompts(),\n        this.registerResourceTemplates(),\n      ]);\n\n    this.instructions = instructions;\n    this.tools = tools;\n    this.resources = resources;\n    this.prompts = prompts;\n    this.resourceTemplates = resourceTemplates;\n\n    this.connectionState = \"ready\";\n  }\n\n  /**\n   * Notification handler registration\n   */\n  async registerTools(): Promise<Tool[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.tools) {\n      return [];\n    }\n\n    if (this.serverCapabilities.tools.listChanged) {\n      this.client.setNotificationHandler(\n        ToolListChangedNotificationSchema,\n        async (_notification) => {\n          this.tools = await this.fetchTools();\n        }\n      );\n    }\n\n    return this.fetchTools();\n  }\n\n  async registerResources(): Promise<Resource[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.resources) {\n      return [];\n    }\n\n    if (this.serverCapabilities.resources.listChanged) {\n      this.client.setNotificationHandler(\n        ResourceListChangedNotificationSchema,\n        async (_notification) => {\n          this.resources = await this.fetchResources();\n        }\n      );\n    }\n\n    return this.fetchResources();\n  }\n\n  async registerPrompts(): Promise<Prompt[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.prompts) {\n      return [];\n    }\n\n    if (this.serverCapabilities.prompts.listChanged) {\n      this.client.setNotificationHandler(\n        PromptListChangedNotificationSchema,\n        async (_notification) => {\n          this.prompts = await this.fetchPrompts();\n        }\n      );\n    }\n\n    return this.fetchPrompts();\n  }\n\n  async registerResourceTemplates(): Promise<ResourceTemplate[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.resources) {\n      return [];\n    }\n\n    return this.fetchResourceTemplates();\n  }\n\n  async fetchTools() {\n    let toolsAgg: Tool[] = [];\n    let toolsResult: ListToolsResult = { tools: [] };\n    do {\n      toolsResult = await this.client\n        .listTools({\n          cursor: toolsResult.nextCursor,\n        })\n        .catch(capabilityErrorHandler({ tools: [] }, \"tools/list\"));\n      toolsAgg = toolsAgg.concat(toolsResult.tools);\n    } while (toolsResult.nextCursor);\n    return toolsAgg;\n  }\n\n  async fetchResources() {\n    let resourcesAgg: Resource[] = [];\n    let resourcesResult: ListResourcesResult = { resources: [] };\n    do {\n      resourcesResult = await this.client\n        .listResources({\n          cursor: resourcesResult.nextCursor,\n        })\n        .catch(capabilityErrorHandler({ resources: [] }, \"resources/list\"));\n      resourcesAgg = resourcesAgg.concat(resourcesResult.resources);\n    } while (resourcesResult.nextCursor);\n    return resourcesAgg;\n  }\n\n  async fetchPrompts() {\n    let promptsAgg: Prompt[] = [];\n    let promptsResult: ListPromptsResult = { prompts: [] };\n    do {\n      promptsResult = await this.client\n        .listPrompts({\n          cursor: promptsResult.nextCursor,\n        })\n        .catch(capabilityErrorHandler({ prompts: [] }, \"prompts/list\"));\n      promptsAgg = promptsAgg.concat(promptsResult.prompts);\n    } while (promptsResult.nextCursor);\n    return promptsAgg;\n  }\n\n  async fetchResourceTemplates() {\n    let templatesAgg: ResourceTemplate[] = [];\n    let templatesResult: ListResourceTemplatesResult = {\n      resourceTemplates: [],\n    };\n    do {\n      templatesResult = await this.client\n        .listResourceTemplates({\n          cursor: templatesResult.nextCursor,\n        })\n        .catch(\n          capabilityErrorHandler(\n            { resourceTemplates: [] },\n            \"resources/templates/list\"\n          )\n        );\n      templatesAgg = templatesAgg.concat(templatesResult.resourceTemplates);\n    } while (templatesResult.nextCursor);\n    return templatesAgg;\n  }\n}\n\nfunction capabilityErrorHandler<T>(empty: T, method: string) {\n  return (e: { code: number }) => {\n    // server is badly behaved and returning invalid capabilities. This commonly occurs for resource templates\n    if (e.code === -32601) {\n      console.error(\n        `The server advertised support for the capability ${method.split(\"/\")[0]}, but returned \"Method not found\" for '${method}'.`\n      );\n      return empty;\n    }\n    throw e;\n  };\n}\n","import { MCPClientConnection } from \"./client-connection\";\n\nimport type {\n  ClientCapabilities,\n  CallToolRequest,\n  CallToolResultSchema,\n  CompatibilityCallToolResultSchema,\n  ReadResourceRequest,\n  GetPromptRequest,\n  Tool,\n  Resource,\n  Prompt,\n  ResourceTemplate,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type { SSEClientTransportOptions } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport type { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type { RequestOptions } from \"@modelcontextprotocol/sdk/shared/protocol.js\";\nimport type { AgentsOAuthProvider } from \"./do-oauth-client-provider\";\nimport { jsonSchema, type ToolSet } from \"ai\";\nimport { nanoid } from \"nanoid\";\n\n/**\n * Utility class that aggregates multiple MCP clients into one\n */\nexport class MCPClientManager {\n  public mcpConnections: Record<string, MCPClientConnection> = {};\n  private callbackUrls: string[] = [];\n\n  /**\n   * @param name Name of the MCP client\n   * @param version Version of the MCP Client\n   * @param auth Auth paramters if being used to create a DurableObjectOAuthClientProvider\n   */\n  constructor(\n    private name: string,\n    private version: string\n  ) {}\n\n  /**\n   * Connect to and register an MCP server\n   *\n   * @param transportConfig Transport config\n   * @param clientConfig Client config\n   * @param capabilities Client capabilities (i.e. if the client supports roots/sampling)\n   */\n  async connect(\n    url: string,\n    options: {\n      // Allows you to reconnect to a server (in the case of a auth reconnect)\n      // Doesn't handle session reconnection\n      reconnect?: {\n        id: string;\n        oauthClientId?: string;\n        oauthCode?: string;\n      };\n      // we're overriding authProvider here because we want to be able to access the auth URL\n      transport?: SSEClientTransportOptions & {\n        authProvider?: AgentsOAuthProvider;\n      };\n      client?: ConstructorParameters<typeof Client>[1];\n      capabilities?: ClientCapabilities;\n    } = {}\n  ): Promise<{ id: string; authUrl: string | undefined }> {\n    const id = options.reconnect?.id ?? nanoid(8);\n\n    if (!options.transport?.authProvider) {\n      console.warn(\n        \"No authProvider provided in the transport options. This client will only support unauthenticated remote MCP Servers\"\n      );\n    } else {\n      options.transport.authProvider.serverId = id;\n    }\n\n    this.mcpConnections[id] = new MCPClientConnection(\n      new URL(url),\n      {\n        name: this.name,\n        version: this.version,\n      },\n      {\n        transport: options.transport ?? {},\n        client: options.client ?? {},\n        capabilities: options.client ?? {},\n      }\n    );\n\n    await this.mcpConnections[id].init(\n      options.reconnect?.oauthCode,\n      options.reconnect?.oauthClientId\n    );\n\n    const authUrl = options.transport?.authProvider?.authUrl;\n    if (authUrl && options.transport?.authProvider?.redirectUrl) {\n      this.callbackUrls.push(\n        options.transport.authProvider.redirectUrl.toString()\n      );\n    }\n\n    return {\n      id,\n      authUrl,\n    };\n  }\n\n  isCallbackRequest(req: Request): boolean {\n    return (\n      req.method === \"GET\" &&\n      !!this.callbackUrls.find((url) => {\n        return req.url.startsWith(url);\n      })\n    );\n  }\n\n  async handleCallbackRequest(req: Request) {\n    const url = new URL(req.url);\n    const urlMatch = this.callbackUrls.find((url) => {\n      return req.url.startsWith(url);\n    });\n    if (!urlMatch) {\n      throw new Error(\n        `No callback URI match found for the request url: ${req.url}. Was the request matched with \\`isCallbackRequest()\\`?`\n      );\n    }\n    const code = url.searchParams.get(\"code\");\n    const clientId = url.searchParams.get(\"state\");\n    const urlParams = urlMatch.split(\"/\");\n    const serverId = urlParams[urlParams.length - 1];\n    if (!code) {\n      throw new Error(\"Unauthorized: no code provided\");\n    }\n    if (!clientId) {\n      throw new Error(\"Unauthorized: no state provided\");\n    }\n\n    if (this.mcpConnections[serverId] === undefined) {\n      throw new Error(`Could not find serverId: ${serverId}`);\n    }\n\n    if (this.mcpConnections[serverId].connectionState !== \"authenticating\") {\n      throw new Error(\n        \"Failed to authenticate: the client isn't in the `authenticating` state\"\n      );\n    }\n\n    const conn = this.mcpConnections[serverId];\n    if (!conn.options.transport.authProvider) {\n      throw new Error(\n        \"Trying to finalize authentication for a server connection without an authProvider\"\n      );\n    }\n\n    conn.options.transport.authProvider.clientId = clientId;\n    conn.options.transport.authProvider.serverId = serverId;\n\n    // reconnect to server with authorization\n    const serverUrl = conn.url.toString();\n    await this.connect(serverUrl, {\n      reconnect: {\n        id: serverId,\n        oauthClientId: clientId,\n        oauthCode: code,\n      },\n      ...conn.options,\n    });\n\n    if (this.mcpConnections[serverId].connectionState === \"authenticating\") {\n      throw new Error(\"Failed to authenticate: client failed to initialize\");\n    }\n\n    return { serverId };\n  }\n\n  /**\n   * @returns namespaced list of tools\n   */\n  listTools(): NamespacedData[\"tools\"] {\n    return getNamespacedData(this.mcpConnections, \"tools\");\n  }\n\n  /**\n   * @returns a set of tools that you can use with the AI SDK\n   */\n  unstable_getAITools(): ToolSet {\n    return Object.fromEntries(\n      getNamespacedData(this.mcpConnections, \"tools\").map((tool) => {\n        return [\n          `${tool.serverId}_${tool.name}`,\n          {\n            parameters: jsonSchema(tool.inputSchema),\n            description: tool.description,\n            execute: async (args) => {\n              const result = await this.callTool({\n                name: tool.name,\n                arguments: args,\n                serverId: tool.serverId,\n              });\n              if (result.isError) {\n                // @ts-expect-error TODO we should fix this\n                throw new Error(result.content[0].text);\n              }\n              return result;\n            },\n          },\n        ];\n      })\n    );\n  }\n\n  /**\n   * Closes all connections to MCP servers\n   */\n  async closeAllConnections() {\n    return Promise.all(\n      Object.values(this.mcpConnections).map(async (connection) => {\n        await connection.client.close();\n      })\n    );\n  }\n\n  /**\n   * Closes a connection to an MCP server\n   * @param id The id of the connection to close\n   */\n  async closeConnection(id: string) {\n    if (!this.mcpConnections[id]) {\n      throw new Error(`Connection with id \"${id}\" does not exist.`);\n    }\n    await this.mcpConnections[id].client.close();\n  }\n\n  /**\n   * @returns namespaced list of prompts\n   */\n  listPrompts(): NamespacedData[\"prompts\"] {\n    return getNamespacedData(this.mcpConnections, \"prompts\");\n  }\n\n  /**\n   * @returns namespaced list of tools\n   */\n  listResources(): NamespacedData[\"resources\"] {\n    return getNamespacedData(this.mcpConnections, \"resources\");\n  }\n\n  /**\n   * @returns namespaced list of resource templates\n   */\n  listResourceTemplates(): NamespacedData[\"resourceTemplates\"] {\n    return getNamespacedData(this.mcpConnections, \"resourceTemplates\");\n  }\n\n  /**\n   * Namespaced version of callTool\n   */\n  callTool(\n    params: CallToolRequest[\"params\"] & { serverId: string },\n    resultSchema?:\n      | typeof CallToolResultSchema\n      | typeof CompatibilityCallToolResultSchema,\n    options?: RequestOptions\n  ) {\n    const unqualifiedName = params.name.replace(`${params.serverId}.`, \"\");\n    return this.mcpConnections[params.serverId].client.callTool(\n      {\n        ...params,\n        name: unqualifiedName,\n      },\n      resultSchema,\n      options\n    );\n  }\n\n  /**\n   * Namespaced version of readResource\n   */\n  readResource(\n    params: ReadResourceRequest[\"params\"] & { serverId: string },\n    options: RequestOptions\n  ) {\n    return this.mcpConnections[params.serverId].client.readResource(\n      params,\n      options\n    );\n  }\n\n  /**\n   * Namespaced version of getPrompt\n   */\n  getPrompt(\n    params: GetPromptRequest[\"params\"] & { serverId: string },\n    options: RequestOptions\n  ) {\n    return this.mcpConnections[params.serverId].client.getPrompt(\n      params,\n      options\n    );\n  }\n}\n\ntype NamespacedData = {\n  tools: (Tool & { serverId: string })[];\n  prompts: (Prompt & { serverId: string })[];\n  resources: (Resource & { serverId: string })[];\n  resourceTemplates: (ResourceTemplate & { serverId: string })[];\n};\n\nexport function getNamespacedData<T extends keyof NamespacedData>(\n  mcpClients: Record<string, MCPClientConnection>,\n  type: T\n): NamespacedData[T] {\n  const sets = Object.entries(mcpClients).map(([name, conn]) => {\n    return { name, data: conn[type] };\n  });\n\n  const namespacedData = sets.flatMap(({ name: serverId, data }) => {\n    return data.map((item) => {\n      return {\n        ...item,\n        // we add a serverId so we can easily pull it out and send the tool call to the right server\n        serverId,\n      };\n    });\n  });\n\n  return namespacedData as NamespacedData[T]; // Type assertion needed due to TS limitations with conditional return types\n}\n"],"mappings":"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","names":["url"]}