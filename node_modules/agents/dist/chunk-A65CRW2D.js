import {
  MCPClientManager
} from "./chunk-Q5ZBHY4Z.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet
} from "./chunk-HMLY7DHA.js";

// src/index.ts
import {
  Server,
  routePartykitRequest,
  getServerByName
} from "partyserver";
import { parseCronExpression } from "cron-schedule";
import { nanoid } from "nanoid";
import { AsyncLocalStorage } from "node:async_hooks";
function isRPCRequest(msg) {
  return typeof msg === "object" && msg !== null && "type" in msg && msg.type === "rpc" && "id" in msg && typeof msg.id === "string" && "method" in msg && typeof msg.method === "string" && "args" in msg && Array.isArray(msg.args);
}
function isStateUpdateMessage(msg) {
  return typeof msg === "object" && msg !== null && "type" in msg && msg.type === "cf_agent_state" && "state" in msg;
}
var callableMetadata = /* @__PURE__ */ new Map();
function unstable_callable(metadata = {}) {
  return function callableDecorator(target, context) {
    if (!callableMetadata.has(target)) {
      callableMetadata.set(target, metadata);
    }
    return target;
  };
}
function getNextCronTime(cron) {
  const interval = parseCronExpression(cron);
  return interval.getNextDate();
}
var STATE_ROW_ID = "cf_state_row_id";
var STATE_WAS_CHANGED = "cf_state_was_changed";
var DEFAULT_STATE = {};
var agentContext = new AsyncLocalStorage();
function getCurrentAgent() {
  const store = agentContext.getStore();
  if (!store) {
    return {
      agent: void 0,
      // yes I know this is icky
      connection: void 0,
      request: void 0
    };
  }
  return store;
}
var _state, _ParentClass, _Agent_instances, setStateInternal_fn, tryCatch_fn, scheduleNextAlarm_fn, isCallable_fn;
var Agent = class extends Server {
  constructor(ctx, env) {
    super(ctx, env);
    __privateAdd(this, _Agent_instances);
    __privateAdd(this, _state, DEFAULT_STATE);
    __privateAdd(this, _ParentClass, Object.getPrototypeOf(this).constructor);
    this.mcp = new MCPClientManager(__privateGet(this, _ParentClass).name, "0.0.1");
    /**
     * Initial state for the Agent
     * Override to provide default state values
     */
    this.initialState = DEFAULT_STATE;
    this.sql`
      CREATE TABLE IF NOT EXISTS cf_agents_state (
        id TEXT PRIMARY KEY NOT NULL,
        state TEXT
      )
    `;
    void this.ctx.blockConcurrencyWhile(async () => {
      return __privateMethod(this, _Agent_instances, tryCatch_fn).call(this, async () => {
        this.sql`
        CREATE TABLE IF NOT EXISTS cf_agents_schedules (
          id TEXT PRIMARY KEY NOT NULL DEFAULT (randomblob(9)),
          callback TEXT,
          payload TEXT,
          type TEXT NOT NULL CHECK(type IN ('scheduled', 'delayed', 'cron')),
          time INTEGER,
          delayInSeconds INTEGER,
          cron TEXT,
          created_at INTEGER DEFAULT (unixepoch())
        )
      `;
        await this.alarm();
      });
    });
    const _onMessage = this.onMessage.bind(this);
    this.onMessage = async (connection, message) => {
      return agentContext.run(
        { agent: this, connection, request: void 0 },
        async () => {
          if (typeof message !== "string") {
            return __privateMethod(this, _Agent_instances, tryCatch_fn).call(this, () => _onMessage(connection, message));
          }
          let parsed;
          try {
            parsed = JSON.parse(message);
          } catch (e) {
            return __privateMethod(this, _Agent_instances, tryCatch_fn).call(this, () => _onMessage(connection, message));
          }
          if (isStateUpdateMessage(parsed)) {
            __privateMethod(this, _Agent_instances, setStateInternal_fn).call(this, parsed.state, connection);
            return;
          }
          if (isRPCRequest(parsed)) {
            try {
              const { id, method, args } = parsed;
              const methodFn = this[method];
              if (typeof methodFn !== "function") {
                throw new Error(`Method ${method} does not exist`);
              }
              if (!__privateMethod(this, _Agent_instances, isCallable_fn).call(this, method)) {
                throw new Error(`Method ${method} is not callable`);
              }
              const metadata = callableMetadata.get(methodFn);
              if (metadata?.streaming) {
                const stream = new StreamingResponse(connection, id);
                await methodFn.apply(this, [stream, ...args]);
                return;
              }
              const result = await methodFn.apply(this, args);
              const response = {
                type: "rpc",
                id,
                success: true,
                result,
                done: true
              };
              connection.send(JSON.stringify(response));
            } catch (e) {
              const response = {
                type: "rpc",
                id: parsed.id,
                success: false,
                error: e instanceof Error ? e.message : "Unknown error occurred"
              };
              connection.send(JSON.stringify(response));
              console.error("RPC error:", e);
            }
            return;
          }
          return __privateMethod(this, _Agent_instances, tryCatch_fn).call(this, () => _onMessage(connection, message));
        }
      );
    };
    const _onConnect = this.onConnect.bind(this);
    this.onConnect = (connection, ctx2) => {
      return agentContext.run(
        { agent: this, connection, request: ctx2.request },
        async () => {
          setTimeout(() => {
            if (this.state) {
              connection.send(
                JSON.stringify({
                  type: "cf_agent_state",
                  state: this.state
                })
              );
            }
            return __privateMethod(this, _Agent_instances, tryCatch_fn).call(this, () => _onConnect(connection, ctx2));
          }, 20);
        }
      );
    };
  }
  /**
   * Current state of the Agent
   */
  get state() {
    if (__privateGet(this, _state) !== DEFAULT_STATE) {
      return __privateGet(this, _state);
    }
    const wasChanged = this.sql`
        SELECT state FROM cf_agents_state WHERE id = ${STATE_WAS_CHANGED}
      `;
    const result = this.sql`
      SELECT state FROM cf_agents_state WHERE id = ${STATE_ROW_ID}
    `;
    if (wasChanged[0]?.state === "true" || // we do this check for people who updated their code before we shipped wasChanged
    result[0]?.state) {
      const state = result[0]?.state;
      __privateSet(this, _state, JSON.parse(state));
      return __privateGet(this, _state);
    }
    if (this.initialState === DEFAULT_STATE) {
      return void 0;
    }
    this.setState(this.initialState);
    return this.initialState;
  }
  /**
   * Execute SQL queries against the Agent's database
   * @template T Type of the returned rows
   * @param strings SQL query template strings
   * @param values Values to be inserted into the query
   * @returns Array of query results
   */
  sql(strings, ...values) {
    let query = "";
    try {
      query = strings.reduce(
        (acc, str, i) => acc + str + (i < values.length ? "?" : ""),
        ""
      );
      return [...this.ctx.storage.sql.exec(query, ...values)];
    } catch (e) {
      console.error(`failed to execute sql query: ${query}`, e);
      throw this.onError(e);
    }
  }
  /**
   * Update the Agent's state
   * @param state New state to set
   */
  setState(state) {
    __privateMethod(this, _Agent_instances, setStateInternal_fn).call(this, state, "server");
  }
  /**
   * Called when the Agent's state is updated
   * @param state Updated state
   * @param source Source of the state update ("server" or a client connection)
   */
  onStateUpdate(state, source) {
  }
  /**
   * Called when the Agent receives an email
   * @param email Email message to process
   */
  onEmail(email) {
    return agentContext.run(
      { agent: this, connection: void 0, request: void 0 },
      async () => {
        console.error("onEmail not implemented");
      }
    );
  }
  onError(connectionOrError, error) {
    let theError;
    if (connectionOrError && error) {
      theError = error;
      console.error(
        "Error on websocket connection:",
        connectionOrError.id,
        theError
      );
      console.error(
        "Override onError(connection, error) to handle websocket connection errors"
      );
    } else {
      theError = connectionOrError;
      console.error("Error on server:", theError);
      console.error("Override onError(error) to handle server errors");
    }
    throw theError;
  }
  /**
   * Render content (not implemented in base class)
   */
  render() {
    throw new Error("Not implemented");
  }
  /**
   * Schedule a task to be executed in the future
   * @template T Type of the payload data
   * @param when When to execute the task (Date, seconds delay, or cron expression)
   * @param callback Name of the method to call
   * @param payload Data to pass to the callback
   * @returns Schedule object representing the scheduled task
   */
  async schedule(when, callback, payload) {
    const id = nanoid(9);
    if (typeof callback !== "string") {
      throw new Error("Callback must be a string");
    }
    if (typeof this[callback] !== "function") {
      throw new Error(`this.${callback} is not a function`);
    }
    if (when instanceof Date) {
      const timestamp = Math.floor(when.getTime() / 1e3);
      this.sql`
        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(
        payload
      )}, 'scheduled', ${timestamp})
      `;
      await __privateMethod(this, _Agent_instances, scheduleNextAlarm_fn).call(this);
      return {
        id,
        callback,
        payload,
        time: timestamp,
        type: "scheduled"
      };
    }
    if (typeof when === "number") {
      const time = new Date(Date.now() + when * 1e3);
      const timestamp = Math.floor(time.getTime() / 1e3);
      this.sql`
        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, delayInSeconds, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(
        payload
      )}, 'delayed', ${when}, ${timestamp})
      `;
      await __privateMethod(this, _Agent_instances, scheduleNextAlarm_fn).call(this);
      return {
        id,
        callback,
        payload,
        delayInSeconds: when,
        time: timestamp,
        type: "delayed"
      };
    }
    if (typeof when === "string") {
      const nextExecutionTime = getNextCronTime(when);
      const timestamp = Math.floor(nextExecutionTime.getTime() / 1e3);
      this.sql`
        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, cron, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(
        payload
      )}, 'cron', ${when}, ${timestamp})
      `;
      await __privateMethod(this, _Agent_instances, scheduleNextAlarm_fn).call(this);
      return {
        id,
        callback,
        payload,
        cron: when,
        time: timestamp,
        type: "cron"
      };
    }
    throw new Error("Invalid schedule type");
  }
  /**
   * Get a scheduled task by ID
   * @template T Type of the payload data
   * @param id ID of the scheduled task
   * @returns The Schedule object or undefined if not found
   */
  async getSchedule(id) {
    const result = this.sql`
      SELECT * FROM cf_agents_schedules WHERE id = ${id}
    `;
    if (!result) {
      console.error(`schedule ${id} not found`);
      return void 0;
    }
    return { ...result[0], payload: JSON.parse(result[0].payload) };
  }
  /**
   * Get scheduled tasks matching the given criteria
   * @template T Type of the payload data
   * @param criteria Criteria to filter schedules
   * @returns Array of matching Schedule objects
   */
  getSchedules(criteria = {}) {
    let query = "SELECT * FROM cf_agents_schedules WHERE 1=1";
    const params = [];
    if (criteria.id) {
      query += " AND id = ?";
      params.push(criteria.id);
    }
    if (criteria.type) {
      query += " AND type = ?";
      params.push(criteria.type);
    }
    if (criteria.timeRange) {
      query += " AND time >= ? AND time <= ?";
      const start = criteria.timeRange.start || /* @__PURE__ */ new Date(0);
      const end = criteria.timeRange.end || /* @__PURE__ */ new Date(999999999999999);
      params.push(
        Math.floor(start.getTime() / 1e3),
        Math.floor(end.getTime() / 1e3)
      );
    }
    const result = this.ctx.storage.sql.exec(query, ...params).toArray().map((row) => ({
      ...row,
      payload: JSON.parse(row.payload)
    }));
    return result;
  }
  /**
   * Cancel a scheduled task
   * @param id ID of the task to cancel
   * @returns true if the task was cancelled, false otherwise
   */
  async cancelSchedule(id) {
    this.sql`DELETE FROM cf_agents_schedules WHERE id = ${id}`;
    await __privateMethod(this, _Agent_instances, scheduleNextAlarm_fn).call(this);
    return true;
  }
  /**
   * Method called when an alarm fires
   * Executes any scheduled tasks that are due
   */
  async alarm() {
    const now = Math.floor(Date.now() / 1e3);
    const result = this.sql`
      SELECT * FROM cf_agents_schedules WHERE time <= ${now}
    `;
    for (const row of result || []) {
      const callback = this[row.callback];
      if (!callback) {
        console.error(`callback ${row.callback} not found`);
        continue;
      }
      await agentContext.run(
        { agent: this, connection: void 0, request: void 0 },
        async () => {
          try {
            await callback.bind(this)(JSON.parse(row.payload), row);
          } catch (e) {
            console.error(`error executing callback "${row.callback}"`, e);
          }
        }
      );
      if (row.type === "cron") {
        const nextExecutionTime = getNextCronTime(row.cron);
        const nextTimestamp = Math.floor(nextExecutionTime.getTime() / 1e3);
        this.sql`
          UPDATE cf_agents_schedules SET time = ${nextTimestamp} WHERE id = ${row.id}
        `;
      } else {
        this.sql`
          DELETE FROM cf_agents_schedules WHERE id = ${row.id}
        `;
      }
    }
    await __privateMethod(this, _Agent_instances, scheduleNextAlarm_fn).call(this);
  }
  /**
   * Destroy the Agent, removing all state and scheduled tasks
   */
  async destroy() {
    this.sql`DROP TABLE IF EXISTS cf_agents_state`;
    this.sql`DROP TABLE IF EXISTS cf_agents_schedules`;
    await this.ctx.storage.deleteAlarm();
    await this.ctx.storage.deleteAll();
  }
};
_state = new WeakMap();
_ParentClass = new WeakMap();
_Agent_instances = new WeakSet();
setStateInternal_fn = function(state, source = "server") {
  __privateSet(this, _state, state);
  this.sql`
    INSERT OR REPLACE INTO cf_agents_state (id, state)
    VALUES (${STATE_ROW_ID}, ${JSON.stringify(state)})
  `;
  this.sql`
    INSERT OR REPLACE INTO cf_agents_state (id, state)
    VALUES (${STATE_WAS_CHANGED}, ${JSON.stringify(true)})
  `;
  this.broadcast(
    JSON.stringify({
      type: "cf_agent_state",
      state
    }),
    source !== "server" ? [source.id] : []
  );
  return __privateMethod(this, _Agent_instances, tryCatch_fn).call(this, () => {
    const { connection, request } = agentContext.getStore() || {};
    return agentContext.run(
      { agent: this, connection, request },
      async () => {
        return this.onStateUpdate(state, source);
      }
    );
  });
};
tryCatch_fn = async function(fn) {
  try {
    return await fn();
  } catch (e) {
    throw this.onError(e);
  }
};
scheduleNextAlarm_fn = async function() {
  const result = this.sql`
      SELECT time FROM cf_agents_schedules 
      WHERE time > ${Math.floor(Date.now() / 1e3)}
      ORDER BY time ASC 
      LIMIT 1
    `;
  if (!result) return;
  if (result.length > 0 && "time" in result[0]) {
    const nextTime = result[0].time * 1e3;
    await this.ctx.storage.setAlarm(nextTime);
  }
};
/**
 * Get all methods marked as callable on this Agent
 * @returns A map of method names to their metadata
 */
isCallable_fn = function(method) {
  return callableMetadata.has(this[method]);
};
/**
 * Agent configuration options
 */
Agent.options = {
  /** Whether the Agent should hibernate when inactive */
  hibernate: true
  // default to hibernate
};
async function routeAgentRequest(request, env, options) {
  const corsHeaders = options?.cors === true ? {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, POST, HEAD, OPTIONS",
    "Access-Control-Allow-Credentials": "true",
    "Access-Control-Max-Age": "86400"
  } : options?.cors;
  if (request.method === "OPTIONS") {
    if (corsHeaders) {
      return new Response(null, {
        headers: corsHeaders
      });
    }
    console.warn(
      "Received an OPTIONS request, but cors was not enabled. Pass `cors: true` or `cors: { ...custom cors headers }` to routeAgentRequest to enable CORS."
    );
  }
  let response = await routePartykitRequest(
    request,
    env,
    {
      prefix: "agents",
      ...options
    }
  );
  if (response && corsHeaders && request.headers.get("upgrade")?.toLowerCase() !== "websocket" && request.headers.get("Upgrade")?.toLowerCase() !== "websocket") {
    response = new Response(response.body, {
      headers: {
        ...response.headers,
        ...corsHeaders
      }
    });
  }
  return response;
}
async function routeAgentEmail(email, env, options) {
}
async function getAgentByName(namespace, name, options) {
  return getServerByName(namespace, name, options);
}
var _connection, _id, _closed;
var StreamingResponse = class {
  constructor(connection, id) {
    __privateAdd(this, _connection);
    __privateAdd(this, _id);
    __privateAdd(this, _closed, false);
    __privateSet(this, _connection, connection);
    __privateSet(this, _id, id);
  }
  /**
   * Send a chunk of data to the client
   * @param chunk The data to send
   */
  send(chunk) {
    if (__privateGet(this, _closed)) {
      throw new Error("StreamingResponse is already closed");
    }
    const response = {
      type: "rpc",
      id: __privateGet(this, _id),
      success: true,
      result: chunk,
      done: false
    };
    __privateGet(this, _connection).send(JSON.stringify(response));
  }
  /**
   * End the stream and send the final chunk (if any)
   * @param finalChunk Optional final chunk of data to send
   */
  end(finalChunk) {
    if (__privateGet(this, _closed)) {
      throw new Error("StreamingResponse is already closed");
    }
    __privateSet(this, _closed, true);
    const response = {
      type: "rpc",
      id: __privateGet(this, _id),
      success: true,
      result: finalChunk,
      done: true
    };
    __privateGet(this, _connection).send(JSON.stringify(response));
  }
};
_connection = new WeakMap();
_id = new WeakMap();
_closed = new WeakMap();

export {
  unstable_callable,
  getCurrentAgent,
  Agent,
  routeAgentRequest,
  routeAgentEmail,
  getAgentByName,
  StreamingResponse
};
//# sourceMappingURL=chunk-A65CRW2D.js.map